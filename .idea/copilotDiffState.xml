<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/api/jinjya_deregister.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_deregister.ts" />
              <option name="originalContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDeregister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;let data: any;&#10;&#9;try {&#10;&#9;&#9;data = await request.json();&#10;&#9;} catch {&#10;&#9;&#9;return new Response(&quot;Invalid JSON&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const { id, owner, spreadsheet_url } = data;&#10;&#9;&#9;return new Response(&quot;Missing required fields&quot;, { status: 400 });&#10;&#9;&#9;return new Response(&quot;Missing required fields&quot;, { status: 400 });&#10;&#9;// 一致するレコードの確認&#10;&#9;// 一致するレコードの確認&#10;&#9;// 一致するレコードの確認&#10;&#9;const check = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id FROM jinjya WHERE id = ? AND owner = ? AND spreadsheet_url = ?`&#10;&#9;).bind(id, owner, spreadsheet_url).first();&#10;&#10;&#9;if (!check) {&#10;&#9;&#9;return new Response(&quot;一致する神社が見つかりません&quot;, { status: 404 });&#10;" />
              <option name="updatedContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDeregister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;let data: any;&#10;&#9;try {&#10;&#9;&#9;data = await request.json();&#10;&#9;} catch {&#10;&#9;&#9;return new Response(&quot;Invalid JSON&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const { id, owner, spreadsheet_url } = data;&#10;&#10;&#9;if (!id || !owner || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing required fields (id, owner, spreadsheet_url)&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const record = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT owner, spreadsheet_url FROM jinjya WHERE id = ? LIMIT 1`&#10;&#9;).bind(id).first&lt;{ owner: string, spreadsheet_url: string }&gt;();&#10;&#10;&#9;if (!record) {&#10;&#9;&#9;return new Response(&quot;神社が見つかりません&quot;, { status: 404 });&#10;&#9;}&#10;&#10;&#9;if (record.owner !== owner || record.spreadsheet_url !== spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;認証エラー：オーナーまたはURLが一致しません&quot;, { status: 403 });&#10;&#9;}&#10;&#10;&#9;await env.JINJYA_DB.prepare(&#10;&#9;&#9;`DELETE FROM jinjya WHERE id = ?`&#10;&#9;).bind(id).run();&#10;&#10;&#9;return new Response(`神社「${id}」を削除しました`, { status: 200 });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/jinjya_list.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_list.ts" />
              <option name="originalContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleJinjyaList(env: Env): Promise&lt;Response&gt; {&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;&#10;export async function handleList(env: Env): Promise&lt;Response&gt; {&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;" />
              <option name="updatedContent" value="import { Env } from '../../types/worker-configuration';&#10;import { checkRateLimit } from '../utils/checkRateLimit';&#10;&#10;export async function handleJinjyaList(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;// レート制限チェック&#10;&#9;if (!await checkRateLimit(env, request.headers.get(&quot;CF-Connecting-IP&quot;) || &quot;unknown&quot;)) {&#10;&#9;&#9;return new Response(&quot;Too Many Requests&quot;, { status: 429 });&#10;&#9;}&#10;&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;&#10;export async function handleList(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;// レート制限チェック&#10;&#9;if (!await checkRateLimit(env, request.headers.get(&quot;CF-Connecting-IP&quot;) || &quot;unknown&quot;)) {&#10;&#9;&#9;return new Response(&quot;Too Many Requests&quot;, { status: 429 });&#10;&#9;}&#10;&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/publish.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/publish.ts" />
              <option name="originalContent" value="import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from &quot;../../types/worker-configuration&quot;;&#10;import { z } from &quot;zod&quot;;&#10;&#10;const BUFFER_PREFIX = &quot;buffer:&quot;; // 例: buffer:furin:123456789&#10;const BUFFER_DURATION_MS = 60 * 60 * 1000;&#10;&#10;export async function handlePublish(env: Env): Promise&lt;Response&gt; {&#10;&#9;const now = Date.now();&#10;&#9;const cutoff = now - BUFFER_DURATION_MS;&#10;&#10;&#9;const list = await env.JINJYA_STORE.list({ prefix: BUFFER_PREFIX });&#10;&#10;&#9;// 神社ごとにデータを分ける: Map&lt;string, z.infer&lt;typeof OmikujiSchema&gt;[]&gt;&#10;&#9;const grouped: Record&lt;string, z.infer&lt;typeof OmikujiSchema&gt;[]&gt; = {};&#10;&#10;&#9;for (const key of list.keys) {&#10;&#9;&#9;const [_, jinjyaId, timestampStr] = key.name.split(&quot;:&quot;);&#10;&#9;&#9;const timestamp = parseInt(timestampStr);&#10;&#9;&#9;if (timestamp &lt; cutoff) continue;&#10;&#10;&#9;&#9;const raw = await env.JINJYA_STORE.get(key.name);&#10;&#9;&#9;if (!raw) continue;&#10;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;const parsed = OmikujiSchema.parse(JSON.parse(raw));&#10;&#9;&#9;&#9;if (!grouped[jinjyaId]) grouped[jinjyaId] = [];&#10;&#9;&#9;&#9;grouped[jinjyaId].push(parsed);&#10;&#9;&#9;} catch (e) {&#10;&#9;&#9;&#9;console.warn(&quot;Invalid buffer data:&quot;, e);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;let successCount = 0;&#10;&#9;let errorMessages: string[] = [];&#10;&#10;&#9;for (const jinjyaId of Object.keys(grouped)) {&#10;&#9;&#9;// ① 神社URL取得（D1）&#10;&#9;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;&#9;`SELECT spreadsheet_url FROM jinjya WHERE id = ? LIMIT 1`&#10;&#9;&#9;).bind(jinjyaId).first&lt;string&gt;(&quot;spreadsheet_url&quot;);&#10;&#10;&#9;&#9;if (!result) {&#10;&#9;&#9;&#9;errorMessages.push(`神社ID &quot;${jinjyaId}&quot; のURLが見つかりません`);&#10;&#9;&#9;&#9;continue;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ② POST送信&#10;&#9;&#9;const response = await fetch(result, {&#10;&#9;&#9;&#9;method: &quot;POST&quot;,&#10;&#9;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;&#9;body: JSON.stringify(grouped[jinjyaId]),&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (!response.ok) {&#10;&#9;&#9;&#9;const text = await response.text();&#10;&#9;&#9;&#9;errorMessages.push(`&quot;${jinjyaId}&quot; 投稿失敗: ${text}`);&#10;&#9;&#9;&#9;continue;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ③ 成功したバッファと投稿データを削除&#10;&#9;&#9;for (const entry of grouped[jinjyaId]) {&#10;&#9;&#9;&#9;// バッファの削除&#10;&#9;&#9;&#9;const timeKey = Object.keys(list.keys).find(k =&gt; k.startsWith(`buffer:${jinjyaId}:`) &amp;&amp; k.includes(entry.message));&#10;&#9;&#9;&#9;if (timeKey) {&#10;&#9;&#9;&#9;&#9;await env.JINJYA_STORE.delete(timeKey);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// 投稿データの削除&#10;&#9;&#9;&#9;const submitKey = Object.keys(list.keys).find(k =&gt; k.startsWith(`submit:${jinjyaId}:`) &amp;&amp; k.includes(entry.message));&#10;&#9;&#9;&#9;if (submitKey) {&#10;&#9;&#9;&#9;&#9;await env.JINJYA_STORE.delete(submitKey);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;successCount++;&#10;&#9;}&#10;&#10;&#9;if (successCount === 0) {&#10;&#9;&#9;return new Response(&quot;投稿失敗:\n&quot; + errorMessages.join(&quot;\n&quot;), { status: 500 });&#10;&#9;}&#10;&#10;&#9;return new Response(`成功: ${successCount} 神社\n${errorMessages.join(&quot;\n&quot;)}`, {&#10;&#9;&#9;status: errorMessages.length ? 207 : 200, // マルチステータス&#10;&#9;});&#10;}&#10;" />
              <option name="updatedContent" value="import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from &quot;../../types/worker-configuration&quot;;&#10;import { z } from &quot;zod&quot;;&#10;import { checkRateLimit } from '../utils/checkRateLimit';&#10;&#10;const BUFFER_PREFIX = &quot;buffer:&quot;; // 例: buffer:furin:123456789&#10;const BUFFER_DURATION_MS = 60 * 60 * 1000;&#10;&#10;export async function handlePublish(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;// レート制限チェック&#10;&#9;if (!await checkRateLimit(env, request.headers.get(&quot;CF-Connecting-IP&quot;) || &quot;unknown&quot;)) {&#10;&#9;&#9;return new Response(&quot;Too Many Requests&quot;, { status: 429 });&#10;&#9;}&#10;&#10;&#9;const now = Date.now();&#10;&#9;const cutoff = now - BUFFER_DURATION_MS;&#10;&#10;&#9;const list = await env.JINJYA_STORE.list({ prefix: BUFFER_PREFIX });&#10;&#10;&#9;// 神社ごとにデータを分ける: Map&lt;string, z.infer&lt;typeof OmikujiSchema&gt;[]&gt;&#10;&#9;const grouped: Record&lt;string, z.infer&lt;typeof OmikujiSchema&gt;[]&gt; = {};&#10;&#10;&#9;for (const key of list.keys) {&#10;&#9;&#9;const [_, jinjyaId, timestampStr] = key.name.split(&quot;:&quot;);&#10;&#9;&#9;const timestamp = parseInt(timestampStr);&#10;&#9;&#9;if (timestamp &lt; cutoff) continue;&#10;&#10;&#9;&#9;const raw = await env.JINJYA_STORE.get(key.name);&#10;&#9;&#9;if (!raw) continue;&#10;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;const parsed = OmikujiSchema.parse(JSON.parse(raw));&#10;&#9;&#9;&#9;if (!grouped[jinjyaId]) grouped[jinjyaId] = [];&#10;&#9;&#9;&#9;grouped[jinjyaId].push(parsed);&#10;&#9;&#9;} catch (e) {&#10;&#9;&#9;&#9;console.warn(&quot;Invalid buffer data:&quot;, e);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;let successCount = 0;&#10;&#9;let errorMessages: string[] = [];&#10;&#10;&#9;for (const jinjyaId of Object.keys(grouped)) {&#10;&#9;&#9;// ① 神社URL取得（D1）&#10;&#9;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;&#9;`SELECT spreadsheet_url FROM jinjya WHERE id = ? LIMIT 1`&#10;&#9;&#9;).bind(jinjyaId).first&lt;string&gt;(&quot;spreadsheet_url&quot;);&#10;&#10;&#9;&#9;if (!result) {&#10;&#9;&#9;&#9;errorMessages.push(`神社ID &quot;${jinjyaId}&quot; のURLが見つかりません`);&#10;&#9;&#9;&#9;continue;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ② POST送信&#10;&#9;&#9;const response = await fetch(result, {&#10;&#9;&#9;&#9;method: &quot;POST&quot;,&#10;&#9;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;&#9;body: JSON.stringify(grouped[jinjyaId]),&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (!response.ok) {&#10;&#9;&#9;&#9;const text = await response.text();&#10;&#9;&#9;&#9;errorMessages.push(`&quot;${jinjyaId}&quot; 投稿失敗: ${text}`);&#10;&#9;&#9;&#9;continue;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ③ 成功したバッファと投稿データを削除&#10;&#9;&#9;for (const entry of grouped[jinjyaId]) {&#10;&#9;&#9;&#9;// バッファの削除&#10;&#9;&#9;&#9;const timeKey = Object.keys(list.keys).find(k =&gt; k.startsWith(`buffer:${jinjyaId}:`) &amp;&amp; k.includes(entry.message));&#10;&#9;&#9;&#9;if (timeKey) {&#10;&#9;&#9;&#9;&#9;await env.JINJYA_STORE.delete(timeKey);&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// 投稿データの削除&#10;&#9;&#9;&#9;const submitKey = Object.keys(list.keys).find(k =&gt; k.startsWith(`submit:${jinjyaId}:`) &amp;&amp; k.includes(entry.message));&#10;&#9;&#9;&#9;if (submitKey) {&#10;&#9;&#9;&#9;&#9;await env.JINJYA_STORE.delete(submitKey);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;successCount++;&#10;&#9;}&#10;&#10;&#9;if (successCount === 0) {&#10;&#9;&#9;return new Response(&quot;投稿失敗:\n&quot; + errorMessages.join(&quot;\n&quot;), { status: 500 });&#10;&#9;}&#10;&#10;&#9;return new Response(`成功: ${successCount} 神社\n${errorMessages.join(&quot;\n&quot;)}`, {&#10;&#9;&#9;status: errorMessages.length ? 207 : 200, // マルチステータス&#10;&#9;});&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/read.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/read.ts" />
              <option name="originalContent" value="import { OmikujiSchema } from &quot;./schema&quot;;&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;const BUFFER_PREFIX = &quot;buffer:furin:&quot;; // 現状1神社固定&#10;&#10;export async function handleRead(env: Env): Promise&lt;Response&gt; {&#10;&#9;const list = await env.JINJYA_STORE.list({ prefix: BUFFER_PREFIX });&#10;&#10;&#9;const entries = [];&#10;&#10;&#9;for (const key of list.keys) {&#10;&#9;&#9;const raw = await env.JINJYA_STORE.get(key.name);&#10;&#9;&#9;if (!raw) continue;&#10;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;const parsed = OmikujiSchema.parse(JSON.parse(raw));&#10;&#9;&#9;&#9;entries.push(parsed);&#10;&#9;&#9;} catch (e) {&#10;&#9;&#9;&#9;console.warn(&quot;Invalid entry in buffer:&quot;, key.name);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return new Response(JSON.stringify(entries, null, 2), {&#10;&#9;&#9;headers: {&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;&#9;&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // CORS開放（必要に応じて制限）&#10;&#9;&#9;},&#10;&#9;});&#10;}&#10;" />
              <option name="updatedContent" value="import { OmikujiSchema } from &quot;./schema&quot;;&#10;import { Env } from '../../types/worker-configuration';&#10;import { checkRateLimit } from '../utils/checkRateLimit';&#10;&#10;const BUFFER_PREFIX = &quot;buffer:furin:&quot;; // 現状1神社固定&#10;&#10;export async function handleRead(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;// レート制限チェック&#10;&#9;if (!await checkRateLimit(env, request.headers.get(&quot;CF-Connecting-IP&quot;) || &quot;unknown&quot;)) {&#10;&#9;&#9;return new Response(&quot;Too Many Requests&quot;, { status: 429 });&#10;&#9;}&#10;&#10;&#9;const list = await env.JINJYA_STORE.list({ prefix: BUFFER_PREFIX });&#10;&#10;&#9;const entries = [];&#10;&#10;&#9;for (const key of list.keys) {&#10;&#9;&#9;const raw = await env.JINJYA_STORE.get(key.name);&#10;&#9;&#9;if (!raw) continue;&#10;&#10;&#9;&#9;try {&#10;&#9;&#9;&#9;const parsed = OmikujiSchema.parse(JSON.parse(raw));&#10;&#9;&#9;&#9;entries.push(parsed);&#10;&#9;&#9;} catch (e) {&#10;&#9;&#9;&#9;console.warn(&quot;Invalid entry in buffer:&quot;, key.name);&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return new Response(JSON.stringify(entries, null, 2), {&#10;&#9;&#9;headers: {&#10;&#9;&#9;&#9;&quot;Content-Type&quot;: &quot;application/json&quot;,&#10;&#9;&#9;&#9;&quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;, // CORS開放（必要に応じて制限）&#10;&#9;&#9;},&#10;&#9;});&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/worker-configuration.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/worker-configuration.d.ts" />
              <option name="originalContent" value="/* eslint-disable */&#10;// Generated by Wrangler by running `wrangler types` (hash: 869ac3b4ce0f52ba3b2e0bc70c49089e)&#10;// Runtime types generated with workerd@1.20250730.0 2025-08-02&#10;declare namespace Cloudflare {&#10;&#9;interface Env {&#10;&#9;&#9;JINJYA_STORE: KVNamespace;&#10;&#9;&#9;JINJYA_DB: D1Database;&#10;&#9;}&#10;}&#10;&#10;interface Env extends Cloudflare.Env {}&#10;export {}&#10;// Begin runtime types&#10;/*! *****************************************************************************&#10;Copyright (c) Cloudflare. All rights reserved.&#10;Copyright (c) Microsoft Corporation. All rights reserved.&#10;&#10;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use&#10;this file except in compliance with the License. You may obtain a copy of the&#10;License at http://www.apache.org/licenses/LICENSE-2.0&#10;THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&#10;KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED&#10;WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,&#10;MERCHANTABLITY OR NON-INFRINGEMENT.&#10;See the Apache Version 2.0 License for specific language governing permissions&#10;and limitations under the License.&#10;***************************************************************************** */&#10;/* eslint-disable */&#10;// noinspection JSUnusedGlobalSymbols&#10;declare var onmessage: never;&#10;/**&#10; * An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)&#10; */&#10;declare class DOMException extends Error {&#10;    constructor(message?: string, name?: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/message) */&#10;    readonly message: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/name) */&#10;    readonly name: string;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/code)&#10;     */&#10;    readonly code: number;&#10;    static readonly INDEX_SIZE_ERR: number;&#10;    static readonly DOMSTRING_SIZE_ERR: number;&#10;    static readonly HIERARCHY_REQUEST_ERR: number;&#10;    static readonly WRONG_DOCUMENT_ERR: number;&#10;    static readonly INVALID_CHARACTER_ERR: number;&#10;    static readonly NO_DATA_ALLOWED_ERR: number;&#10;    static readonly NO_MODIFICATION_ALLOWED_ERR: number;&#10;    static readonly NOT_FOUND_ERR: number;&#10;    static readonly NOT_SUPPORTED_ERR: number;&#10;    static readonly INUSE_ATTRIBUTE_ERR: number;&#10;    static readonly INVALID_STATE_ERR: number;&#10;    static readonly SYNTAX_ERR: number;&#10;    static readonly INVALID_MODIFICATION_ERR: number;&#10;    static readonly NAMESPACE_ERR: number;&#10;    static readonly INVALID_ACCESS_ERR: number;&#10;    static readonly VALIDATION_ERR: number;&#10;    static readonly TYPE_MISMATCH_ERR: number;&#10;    static readonly SECURITY_ERR: number;&#10;    static readonly NETWORK_ERR: number;&#10;    static readonly ABORT_ERR: number;&#10;    static readonly URL_MISMATCH_ERR: number;&#10;    static readonly QUOTA_EXCEEDED_ERR: number;&#10;    static readonly TIMEOUT_ERR: number;&#10;    static readonly INVALID_NODE_TYPE_ERR: number;&#10;    static readonly DATA_CLONE_ERR: number;&#10;    get stack(): any;&#10;    set stack(value: any);&#10;}&#10;type WorkerGlobalScopeEventMap = {&#10;    fetch: FetchEvent;&#10;    scheduled: ScheduledEvent;&#10;    queue: QueueEvent;&#10;    unhandledrejection: PromiseRejectionEvent;&#10;    rejectionhandled: PromiseRejectionEvent;&#10;};&#10;declare abstract class WorkerGlobalScope extends EventTarget&lt;WorkerGlobalScopeEventMap&gt; {&#10;    EventTarget: typeof EventTarget;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */&#10;interface Console {&#10;    &quot;assert&quot;(condition?: boolean, ...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/clear_static) */&#10;    clear(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/count_static) */&#10;    count(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/countReset_static) */&#10;    countReset(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/debug_static) */&#10;    debug(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dir_static) */&#10;    dir(item?: any, options?: any): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dirxml_static) */&#10;    dirxml(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/error_static) */&#10;    error(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/group_static) */&#10;    group(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupCollapsed_static) */&#10;    groupCollapsed(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupEnd_static) */&#10;    groupEnd(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/info_static) */&#10;    info(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static) */&#10;    log(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/table_static) */&#10;    table(tabularData?: any, properties?: string[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/time_static) */&#10;    time(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeEnd_static) */&#10;    timeEnd(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeLog_static) */&#10;    timeLog(label?: string, ...data: any[]): void;&#10;    timeStamp(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/trace_static) */&#10;    trace(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/warn_static) */&#10;    warn(...data: any[]): void;&#10;}&#10;declare const console: Console;&#10;type BufferSource = ArrayBufferView | ArrayBuffer;&#10;type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;&#10;declare namespace WebAssembly {&#10;    class CompileError extends Error {&#10;        constructor(message?: string);&#10;    }&#10;    class RuntimeError extends Error {&#10;        constructor(message?: string);&#10;    }&#10;    type ValueType = &quot;anyfunc&quot; | &quot;externref&quot; | &quot;f32&quot; | &quot;f64&quot; | &quot;i32&quot; | &quot;i64&quot; | &quot;v128&quot;;&#10;    interface GlobalDescriptor {&#10;        value: ValueType;&#10;        mutable?: boolean;&#10;    }&#10;    class Global {&#10;        constructor(descriptor: GlobalDescriptor, value?: any);&#10;        value: any;&#10;        valueOf(): any;&#10;    }&#10;    type ImportValue = ExportValue | number;&#10;    type ModuleImports = Record&lt;string, ImportValue&gt;;&#10;    type Imports = Record&lt;string, ModuleImports&gt;;&#10;    type ExportValue = Function | Global | Memory | Table;&#10;    type Exports = Record&lt;string, ExportValue&gt;;&#10;    class Instance {&#10;        constructor(module: Module, imports?: Imports);&#10;        readonly exports: Exports;&#10;    }&#10;    interface MemoryDescriptor {&#10;        initial: number;&#10;        maximum?: number;&#10;        shared?: boolean;&#10;    }&#10;    class Memory {&#10;        constructor(descriptor: MemoryDescriptor);&#10;        readonly buffer: ArrayBuffer;&#10;        grow(delta: number): number;&#10;    }&#10;    type ImportExportKind = &quot;function&quot; | &quot;global&quot; | &quot;memory&quot; | &quot;table&quot;;&#10;    interface ModuleExportDescriptor {&#10;        kind: ImportExportKind;&#10;        name: string;&#10;    }&#10;    interface ModuleImportDescriptor {&#10;        kind: ImportExportKind;&#10;        module: string;&#10;        name: string;&#10;    }&#10;    abstract class Module {&#10;        static customSections(module: Module, sectionName: string): ArrayBuffer[];&#10;        static exports(module: Module): ModuleExportDescriptor[];&#10;        static imports(module: Module): ModuleImportDescriptor[];&#10;    }&#10;    type TableKind = &quot;anyfunc&quot; | &quot;externref&quot;;&#10;    interface TableDescriptor {&#10;        element: TableKind;&#10;        initial: number;&#10;        maximum?: number;&#10;    }&#10;    class Table {&#10;        constructor(descriptor: TableDescriptor, value?: any);&#10;        readonly length: number;&#10;        get(index: number): any;&#10;        grow(delta: number, value?: any): number;&#10;        set(index: number, value?: any): void;&#10;    }&#10;    function instantiate(module: Module, imports?: Imports): Promise&lt;Instance&gt;;&#10;    function validate(bytes: BufferSource): boolean;&#10;}&#10;/**&#10; * This ServiceWorker API interface represents the global execution context of a service worker.&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope)&#10; */&#10;interface ServiceWorkerGlobalScope extends WorkerGlobalScope {&#10;    DOMException: typeof DOMException;&#10;    WorkerGlobalScope: typeof WorkerGlobalScope;&#10;    btoa(data: string): string;&#10;    atob(data: string): string;&#10;    setTimeout(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;    setTimeout&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;    clearTimeout(timeoutId: number | null): void;&#10;    setInterval(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;    setInterval&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;    clearInterval(timeoutId: number | null): void;&#10;    queueMicrotask(task: Function): void;&#10;    structuredClone&lt;T&gt;(value: T, options?: StructuredSerializeOptions): T;&#10;    reportError(error: any): void;&#10;    fetch(input: RequestInfo | URL, init?: RequestInit&lt;RequestInitCfProperties&gt;): Promise&lt;Response&gt;;&#10;    self: ServiceWorkerGlobalScope;&#10;    crypto: Crypto;&#10;    caches: CacheStorage;&#10;    scheduler: Scheduler;&#10;    performance: Performance;&#10;    Cloudflare: Cloudflare;&#10;    readonly origin: string;&#10;    Event: typeof Event;&#10;    ExtendableEvent: typeof ExtendableEvent;&#10;    CustomEvent: typeof CustomEvent;&#10;    PromiseRejectionEvent: typeof PromiseRejectionEvent;&#10;    FetchEvent: typeof FetchEvent;&#10;    TailEvent: typeof TailEvent;&#10;    TraceEvent: typeof TailEvent;&#10;    ScheduledEvent: typeof ScheduledEvent;&#10;    MessageEvent: typeof MessageEvent;&#10;    CloseEvent: typeof CloseEvent;&#10;    ReadableStreamDefaultReader: typeof ReadableStreamDefaultReader;&#10;    ReadableStreamBYOBReader: typeof ReadableStreamBYOBReader;&#10;    ReadableStream: typeof ReadableStream;&#10;    WritableStream: typeof WritableStream;&#10;    WritableStreamDefaultWriter: typeof WritableStreamDefaultWriter;&#10;    TransformStream: typeof TransformStream;&#10;    ByteLengthQueuingStrategy: typeof ByteLengthQueuingStrategy;&#10;    CountQueuingStrategy: typeof CountQueuingStrategy;&#10;    ErrorEvent: typeof ErrorEvent;&#10;    EventSource: typeof EventSource;&#10;    ReadableStreamBYOBRequest: typeof ReadableStreamBYOBRequest;&#10;    ReadableStreamDefaultController: typeof ReadableStreamDefaultController;&#10;    ReadableByteStreamController: typeof ReadableByteStreamController;&#10;    WritableStreamDefaultController: typeof WritableStreamDefaultController;&#10;    TransformStreamDefaultController: typeof TransformStreamDefaultController;&#10;    CompressionStream: typeof CompressionStream;&#10;    DecompressionStream: typeof DecompressionStream;&#10;    TextEncoderStream: typeof TextEncoderStream;&#10;    TextDecoderStream: typeof TextDecoderStream;&#10;    Headers: typeof Headers;&#10;    Body: typeof Body;&#10;    Request: typeof Request;&#10;    Response: typeof Response;&#10;    WebSocket: typeof WebSocket;&#10;    WebSocketPair: typeof WebSocketPair;&#10;    WebSocketRequestResponsePair: typeof WebSocketRequestResponsePair;&#10;    AbortController: typeof AbortController;&#10;    AbortSignal: typeof AbortSignal;&#10;    TextDecoder: typeof TextDecoder;&#10;    TextEncoder: typeof TextEncoder;&#10;    navigator: Navigator;&#10;    Navigator: typeof Navigator;&#10;    URL: typeof URL;&#10;    URLSearchParams: typeof URLSearchParams;&#10;    URLPattern: typeof URLPattern;&#10;    Blob: typeof Blob;&#10;    File: typeof File;&#10;    FormData: typeof FormData;&#10;    Crypto: typeof Crypto;&#10;    SubtleCrypto: typeof SubtleCrypto;&#10;    CryptoKey: typeof CryptoKey;&#10;    CacheStorage: typeof CacheStorage;&#10;    Cache: typeof Cache;&#10;    FixedLengthStream: typeof FixedLengthStream;&#10;    IdentityTransformStream: typeof IdentityTransformStream;&#10;    HTMLRewriter: typeof HTMLRewriter;&#10;}&#10;declare function addEventListener&lt;Type extends keyof WorkerGlobalScopeEventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;WorkerGlobalScopeEventMap[Type]&gt;, options?: EventTargetAddEventListenerOptions | boolean): void;&#10;declare function removeEventListener&lt;Type extends keyof WorkerGlobalScopeEventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;WorkerGlobalScopeEventMap[Type]&gt;, options?: EventTargetEventListenerOptions | boolean): void;&#10;/**&#10; * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)&#10; */&#10;declare function dispatchEvent(event: WorkerGlobalScopeEventMap[keyof WorkerGlobalScopeEventMap]): boolean;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/btoa) */&#10;declare function btoa(data: string): string;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/atob) */&#10;declare function atob(data: string): string;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */&#10;declare function setTimeout(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */&#10;declare function setTimeout&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearTimeout) */&#10;declare function clearTimeout(timeoutId: number | null): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */&#10;declare function setInterval(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */&#10;declare function setInterval&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearInterval) */&#10;declare function clearInterval(timeoutId: number | null): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/queueMicrotask) */&#10;declare function queueMicrotask(task: Function): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/structuredClone) */&#10;declare function structuredClone&lt;T&gt;(value: T, options?: StructuredSerializeOptions): T;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/reportError) */&#10;declare function reportError(error: any): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/fetch) */&#10;declare function fetch(input: RequestInfo | URL, init?: RequestInit&lt;RequestInitCfProperties&gt;): Promise&lt;Response&gt;;&#10;declare const self: ServiceWorkerGlobalScope;&#10;/**&#10;* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.&#10;* The Workers runtime implements the full surface of this API, but with some differences in&#10;* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)&#10;* compared to those implemented in most browsers.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)&#10;*/&#10;declare const crypto: Crypto;&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare const caches: CacheStorage;&#10;declare const scheduler: Scheduler;&#10;/**&#10;* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,&#10;* as well as timing of subrequests and other operations.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)&#10;*/&#10;declare const performance: Performance;&#10;declare const Cloudflare: Cloudflare;&#10;declare const origin: string;&#10;declare const navigator: Navigator;&#10;interface TestController {&#10;}&#10;interface ExecutionContext {&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;    passThroughOnException(): void;&#10;    props: any;&#10;}&#10;type ExportedHandlerFetchHandler&lt;Env = unknown, CfHostMetadata = unknown&gt; = (request: Request&lt;CfHostMetadata, IncomingRequestCfProperties&lt;CfHostMetadata&gt;&gt;, env: Env, ctx: ExecutionContext) =&gt; Response | Promise&lt;Response&gt;;&#10;type ExportedHandlerTailHandler&lt;Env = unknown&gt; = (events: TraceItem[], env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTraceHandler&lt;Env = unknown&gt; = (traces: TraceItem[], env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTailStreamHandler&lt;Env = unknown&gt; = (event: TailStream.TailEvent&lt;TailStream.Onset&gt;, env: Env, ctx: ExecutionContext) =&gt; TailStream.TailEventHandlerType | Promise&lt;TailStream.TailEventHandlerType&gt;;&#10;type ExportedHandlerScheduledHandler&lt;Env = unknown&gt; = (controller: ScheduledController, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerQueueHandler&lt;Env = unknown, Message = unknown&gt; = (batch: MessageBatch&lt;Message&gt;, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTestHandler&lt;Env = unknown&gt; = (controller: TestController, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;interface ExportedHandler&lt;Env = unknown, QueueHandlerMessage = unknown, CfHostMetadata = unknown&gt; {&#10;    fetch?: ExportedHandlerFetchHandler&lt;Env, CfHostMetadata&gt;;&#10;    tail?: ExportedHandlerTailHandler&lt;Env&gt;;&#10;    trace?: ExportedHandlerTraceHandler&lt;Env&gt;;&#10;    tailStream?: ExportedHandlerTailStreamHandler&lt;Env&gt;;&#10;    scheduled?: ExportedHandlerScheduledHandler&lt;Env&gt;;&#10;    test?: ExportedHandlerTestHandler&lt;Env&gt;;&#10;    email?: EmailExportedHandler&lt;Env&gt;;&#10;    queue?: ExportedHandlerQueueHandler&lt;Env, QueueHandlerMessage&gt;;&#10;}&#10;interface StructuredSerializeOptions {&#10;    transfer?: any[];&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */&#10;declare abstract class PromiseRejectionEvent extends Event {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise) */&#10;    readonly promise: Promise&lt;any&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason) */&#10;    readonly reason: any;&#10;}&#10;declare abstract class Navigator {&#10;    sendBeacon(url: string, body?: (ReadableStream | string | (ArrayBuffer | ArrayBufferView) | Blob | FormData | URLSearchParams | URLSearchParams)): boolean;&#10;    readonly userAgent: string;&#10;    readonly hardwareConcurrency: number;&#10;    readonly language: string;&#10;    readonly languages: string[];&#10;}&#10;/**&#10;* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,&#10;* as well as timing of subrequests and other operations.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)&#10;*/&#10;interface Performance {&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancetimeorigin) */&#10;    readonly timeOrigin: number;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancenow) */&#10;    now(): number;&#10;}&#10;interface AlarmInvocationInfo {&#10;    readonly isRetry: boolean;&#10;    readonly retryCount: number;&#10;}&#10;interface Cloudflare {&#10;    readonly compatibilityFlags: Record&lt;string, boolean&gt;;&#10;}&#10;interface DurableObject {&#10;    fetch(request: Request): Response | Promise&lt;Response&gt;;&#10;    alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise&lt;void&gt;;&#10;    webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise&lt;void&gt;;&#10;    webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise&lt;void&gt;;&#10;    webSocketError?(ws: WebSocket, error: unknown): void | Promise&lt;void&gt;;&#10;}&#10;type DurableObjectStub&lt;T extends Rpc.DurableObjectBranded | undefined = undefined&gt; = Fetcher&lt;T, &quot;alarm&quot; | &quot;webSocketMessage&quot; | &quot;webSocketClose&quot; | &quot;webSocketError&quot;&gt; &amp; {&#10;    readonly id: DurableObjectId;&#10;    readonly name?: string;&#10;};&#10;interface DurableObjectId {&#10;    toString(): string;&#10;    equals(other: DurableObjectId): boolean;&#10;    readonly name?: string;&#10;}&#10;interface DurableObjectNamespace&lt;T extends Rpc.DurableObjectBranded | undefined = undefined&gt; {&#10;    newUniqueId(options?: DurableObjectNamespaceNewUniqueIdOptions): DurableObjectId;&#10;    idFromName(name: string): DurableObjectId;&#10;    idFromString(id: string): DurableObjectId;&#10;    get(id: DurableObjectId, options?: DurableObjectNamespaceGetDurableObjectOptions): DurableObjectStub&lt;T&gt;;&#10;    jurisdiction(jurisdiction: DurableObjectJurisdiction): DurableObjectNamespace&lt;T&gt;;&#10;}&#10;type DurableObjectJurisdiction = &quot;eu&quot; | &quot;fedramp&quot; | &quot;fedramp-high&quot;;&#10;interface DurableObjectNamespaceNewUniqueIdOptions {&#10;    jurisdiction?: DurableObjectJurisdiction;&#10;}&#10;type DurableObjectLocationHint = &quot;wnam&quot; | &quot;enam&quot; | &quot;sam&quot; | &quot;weur&quot; | &quot;eeur&quot; | &quot;apac&quot; | &quot;oc&quot; | &quot;afr&quot; | &quot;me&quot;;&#10;interface DurableObjectNamespaceGetDurableObjectOptions {&#10;    locationHint?: DurableObjectLocationHint;&#10;}&#10;interface DurableObjectState {&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;    readonly id: DurableObjectId;&#10;    readonly storage: DurableObjectStorage;&#10;    container?: Container;&#10;    blockConcurrencyWhile&lt;T&gt;(callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;    acceptWebSocket(ws: WebSocket, tags?: string[]): void;&#10;    getWebSockets(tag?: string): WebSocket[];&#10;    setWebSocketAutoResponse(maybeReqResp?: WebSocketRequestResponsePair): void;&#10;    getWebSocketAutoResponse(): WebSocketRequestResponsePair | null;&#10;    getWebSocketAutoResponseTimestamp(ws: WebSocket): Date | null;&#10;    setHibernatableWebSocketEventTimeout(timeoutMs?: number): void;&#10;    getHibernatableWebSocketEventTimeout(): number | null;&#10;    getTags(ws: WebSocket): string[];&#10;    abort(reason?: string): void;&#10;}&#10;interface DurableObjectTransaction {&#10;    get&lt;T = unknown&gt;(key: string, options?: DurableObjectGetOptions): Promise&lt;T | undefined&gt;;&#10;    get&lt;T = unknown&gt;(keys: string[], options?: DurableObjectGetOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    list&lt;T = unknown&gt;(options?: DurableObjectListOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    put&lt;T&gt;(key: string, value: T, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    put&lt;T&gt;(entries: Record&lt;string, T&gt;, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    delete(key: string, options?: DurableObjectPutOptions): Promise&lt;boolean&gt;;&#10;    delete(keys: string[], options?: DurableObjectPutOptions): Promise&lt;number&gt;;&#10;    rollback(): void;&#10;    getAlarm(options?: DurableObjectGetAlarmOptions): Promise&lt;number | null&gt;;&#10;    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;}&#10;interface DurableObjectStorage {&#10;    get&lt;T = unknown&gt;(key: string, options?: DurableObjectGetOptions): Promise&lt;T | undefined&gt;;&#10;    get&lt;T = unknown&gt;(keys: string[], options?: DurableObjectGetOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    list&lt;T = unknown&gt;(options?: DurableObjectListOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    put&lt;T&gt;(key: string, value: T, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    put&lt;T&gt;(entries: Record&lt;string, T&gt;, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    delete(key: string, options?: DurableObjectPutOptions): Promise&lt;boolean&gt;;&#10;    delete(keys: string[], options?: DurableObjectPutOptions): Promise&lt;number&gt;;&#10;    deleteAll(options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    transaction&lt;T&gt;(closure: (txn: DurableObjectTransaction) =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;    getAlarm(options?: DurableObjectGetAlarmOptions): Promise&lt;number | null&gt;;&#10;    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    sync(): Promise&lt;void&gt;;&#10;    sql: SqlStorage;&#10;    transactionSync&lt;T&gt;(closure: () =&gt; T): T;&#10;    getCurrentBookmark(): Promise&lt;string&gt;;&#10;    getBookmarkForTime(timestamp: number | Date): Promise&lt;string&gt;;&#10;    onNextSessionRestoreBookmark(bookmark: string): Promise&lt;string&gt;;&#10;}&#10;interface DurableObjectListOptions {&#10;    start?: string;&#10;    startAfter?: string;&#10;    end?: string;&#10;    prefix?: string;&#10;    reverse?: boolean;&#10;    limit?: number;&#10;    allowConcurrency?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectGetOptions {&#10;    allowConcurrency?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectGetAlarmOptions {&#10;    allowConcurrency?: boolean;&#10;}&#10;interface DurableObjectPutOptions {&#10;    allowConcurrency?: boolean;&#10;    allowUnconfirmed?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectSetAlarmOptions {&#10;    allowConcurrency?: boolean;&#10;    allowUnconfirmed?: boolean;&#10;}&#10;declare class WebSocketRequestResponsePair {&#10;    constructor(request: string, response: string);&#10;    get request(): string;&#10;    get response(): string;&#10;}&#10;interface AnalyticsEngineDataset {&#10;    writeDataPoint(event?: AnalyticsEngineDataPoint): void;&#10;}&#10;interface AnalyticsEngineDataPoint {&#10;    indexes?: ((ArrayBuffer | string) | null)[];&#10;    doubles?: number[];&#10;    blobs?: ((ArrayBuffer | string) | null)[];&#10;}&#10;/**&#10; * An event which takes place in the DOM.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)&#10; */&#10;declare class Event {&#10;    constructor(type: string, init?: EventInit);&#10;    /**&#10;     * Returns the type of event, e.g. &quot;click&quot;, &quot;hashchange&quot;, or &quot;submit&quot;.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/type)&#10;     */&#10;    get type(): string;&#10;    /**&#10;     * Returns the event's phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/eventPhase)&#10;     */&#10;    get eventPhase(): number;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composed)&#10;     */&#10;    get composed(): boolean;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. True if event goes through its target's ancestors in reverse tree order, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/bubbles)&#10;     */&#10;    get bubbles(): boolean;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelable)&#10;     */&#10;    get cancelable(): boolean;&#10;    /**&#10;     * Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/defaultPrevented)&#10;     */&#10;    get defaultPrevented(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/returnValue)&#10;     */&#10;    get returnValue(): boolean;&#10;    /**&#10;     * Returns the object whose event listener's callback is currently being invoked.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/currentTarget)&#10;     */&#10;    get currentTarget(): EventTarget | undefined;&#10;    /**&#10;     * Returns the object to which event is dispatched (its target).&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/target)&#10;     */&#10;    get target(): EventTarget | undefined;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/srcElement)&#10;     */&#10;    get srcElement(): EventTarget | undefined;&#10;    /**&#10;     * Returns the event's timestamp as the number of milliseconds measured relative to the time origin.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/timeStamp)&#10;     */&#10;    get timeStamp(): number;&#10;    /**&#10;     * Returns true if event was dispatched by the user agent, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/isTrusted)&#10;     */&#10;    get isTrusted(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)&#10;     */&#10;    get cancelBubble(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)&#10;     */&#10;    set cancelBubble(value: boolean);&#10;    /**&#10;     * Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopImmediatePropagation)&#10;     */&#10;    stopImmediatePropagation(): void;&#10;    /**&#10;     * If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/preventDefault)&#10;     */&#10;    preventDefault(): void;&#10;    /**&#10;     * When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation)&#10;     */&#10;    stopPropagation(): void;&#10;    /**&#10;     * Returns the invocation target objects of event's path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root's mode is &quot;closed&quot; that are not reachable from event's currentTarget.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composedPath)&#10;     */&#10;    composedPath(): EventTarget[];&#10;    static readonly NONE: number;&#10;    static readonly CAPTURING_PHASE: number;&#10;    static readonly AT_TARGET: number;&#10;    static readonly BUBBLING_PHASE: number;&#10;}&#10;interface EventInit {&#10;    bubbles?: boolean;&#10;    cancelable?: boolean;&#10;    composed?: boolean;&#10;}&#10;type EventListener&lt;EventType extends Event = Event&gt; = (event: EventType) =&gt; void;&#10;interface EventListenerObject&lt;EventType extends Event = Event&gt; {&#10;    handleEvent(event: EventType): void;&#10;}&#10;type EventListenerOrEventListenerObject&lt;EventType extends Event = Event&gt; = EventListener&lt;EventType&gt; | EventListenerObject&lt;EventType&gt;;&#10;/**&#10; * EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)&#10; */&#10;declare class EventTarget&lt;EventMap extends Record&lt;string, Event&gt; = Record&lt;string, Event&gt;&gt; {&#10;    constructor();&#10;    /**&#10;     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.&#10;     *&#10;     * The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.&#10;     *&#10;     * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.&#10;     *&#10;     * When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.&#10;     *&#10;     * When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.&#10;     *&#10;     * If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.&#10;     *&#10;     * The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener)&#10;     */&#10;    addEventListener&lt;Type extends keyof EventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;EventMap[Type]&gt;, options?: EventTargetAddEventListenerOptions | boolean): void;&#10;    /**&#10;     * Removes the event listener in target's event listener list with the same type, callback, and options.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/removeEventListener)&#10;     */&#10;    removeEventListener&lt;Type extends keyof EventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;EventMap[Type]&gt;, options?: EventTargetEventListenerOptions | boolean): void;&#10;    /**&#10;     * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)&#10;     */&#10;    dispatchEvent(event: EventMap[keyof EventMap]): boolean;&#10;}&#10;interface EventTargetEventListenerOptions {&#10;    capture?: boolean;&#10;}&#10;interface EventTargetAddEventListenerOptions {&#10;    capture?: boolean;&#10;    passive?: boolean;&#10;    once?: boolean;&#10;    signal?: AbortSignal;&#10;}&#10;interface EventTargetHandlerObject {&#10;    handleEvent: (event: Event) =&gt; any | undefined;&#10;}&#10;/**&#10; * A controller object that allows you to abort one or more DOM requests as and when desired.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)&#10; */&#10;declare class AbortController {&#10;    constructor();&#10;    /**&#10;     * Returns the AbortSignal object associated with this object.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/signal)&#10;     */&#10;    get signal(): AbortSignal;&#10;    /**&#10;     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/abort)&#10;     */&#10;    abort(reason?: any): void;&#10;}&#10;/**&#10; * A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)&#10; */&#10;declare abstract class AbortSignal extends EventTarget {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_static) */&#10;    static abort(reason?: any): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/timeout_static) */&#10;    static timeout(delay: number): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/any_static) */&#10;    static any(signals: AbortSignal[]): AbortSignal;&#10;    /**&#10;     * Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/aborted)&#10;     */&#10;    get aborted(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/reason) */&#10;    get reason(): any;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */&#10;    get onabort(): any | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */&#10;    set onabort(value: any | null);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/throwIfAborted) */&#10;    throwIfAborted(): void;&#10;}&#10;interface Scheduler {&#10;    wait(delay: number, maybeOptions?: SchedulerWaitOptions): Promise&lt;void&gt;;&#10;}&#10;interface SchedulerWaitOptions {&#10;    signal?: AbortSignal;&#10;}&#10;/**&#10; * Extends the lifetime of the install and activate events dispatched on the global scope as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched until it upgrades database schemas and deletes the outdated cache entries.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent)&#10; */&#10;declare abstract class ExtendableEvent extends Event {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil) */&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */&#10;declare class CustomEvent&lt;T = any&gt; extends Event {&#10;    constructor(type: string, init?: CustomEventCustomEventInit);&#10;    /**&#10;     * Returns any custom data event was created with. Typically used for synthetic events.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent/detail)&#10;     */&#10;    get detail(): T;&#10;}&#10;interface CustomEventCustomEventInit {&#10;    bubbles?: boolean;&#10;    cancelable?: boolean;&#10;    composed?: boolean;&#10;    detail?: any;&#10;}&#10;/**&#10; * A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)&#10; */&#10;declare class Blob {&#10;    constructor(type?: ((ArrayBuffer | ArrayBufferView) | string | Blob)[], options?: BlobOptions);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */&#10;    get size(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */&#10;    get type(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */&#10;    slice(start?: number, end?: number, type?: string): Blob;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/arrayBuffer) */&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/bytes) */&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */&#10;    text(): Promise&lt;string&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/stream) */&#10;    stream(): ReadableStream;&#10;}&#10;interface BlobOptions {&#10;    type?: string;&#10;}&#10;/**&#10; * Provides information about files and allows JavaScript in a web page to access their content.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)&#10; */&#10;declare class File extends Blob {&#10;    constructor(bits: ((ArrayBuffer | ArrayBufferView) | string | Blob)[] | undefined, name: string, options?: FileOptions);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */&#10;    get name(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */&#10;    get lastModified(): number;&#10;}&#10;interface FileOptions {&#10;    type?: string;&#10;    lastModified?: number;&#10;}&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare abstract class CacheStorage {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage/open) */&#10;    open(cacheName: string): Promise&lt;Cache&gt;;&#10;    readonly default: Cache;&#10;}&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare abstract class Cache {&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#delete) */&#10;    delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;boolean&gt;;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#match) */&#10;    match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;Response | undefined&gt;;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#put) */&#10;    put(request: RequestInfo | URL, response: Response): Promise&lt;void&gt;;&#10;}&#10;interface CacheQueryOptions {&#10;    ignoreMethod?: boolean;&#10;}&#10;/**&#10;* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.&#10;* The Workers runtime implements the full surface of this API, but with some differences in&#10;* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)&#10;* compared to those implemented in most browsers.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)&#10;*/&#10;declare abstract class Crypto {&#10;    /**&#10;     * Available only in secure contexts.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/subtle)&#10;     */&#10;    get subtle(): SubtleCrypto;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/getRandomValues) */&#10;    getRandomValues&lt;T extends Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | BigInt64Array | BigUint64Array&gt;(buffer: T): T;&#10;    /**&#10;     * Available only in secure contexts.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/randomUUID)&#10;     */&#10;    randomUUID(): string;&#10;    DigestStream: typeof DigestStream;&#10;}&#10;/**&#10; * This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)&#10; */&#10;declare abstract class SubtleCrypto {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/encrypt) */&#10;    encrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, plainText: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/decrypt) */&#10;    decrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, cipherText: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/sign) */&#10;    sign(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, data: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/verify) */&#10;    verify(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, signature: ArrayBuffer | ArrayBufferView, data: ArrayBuffer | ArrayBufferView): Promise&lt;boolean&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/digest) */&#10;    digest(algorithm: string | SubtleCryptoHashAlgorithm, data: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey) */&#10;    generateKey(algorithm: string | SubtleCryptoGenerateKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey | CryptoKeyPair&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey) */&#10;    deriveKey(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, derivedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveBits) */&#10;    deriveBits(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, length?: number | null): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey) */&#10;    importKey(format: string, keyData: (ArrayBuffer | ArrayBufferView) | JsonWebKey, algorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/exportKey) */&#10;    exportKey(format: string, key: CryptoKey): Promise&lt;ArrayBuffer | JsonWebKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/wrapKey) */&#10;    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: string | SubtleCryptoEncryptAlgorithm): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey) */&#10;    unwrapKey(format: string, wrappedKey: ArrayBuffer | ArrayBufferView, unwrappingKey: CryptoKey, unwrapAlgorithm: string | SubtleCryptoEncryptAlgorithm, unwrappedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    timingSafeEqual(a: ArrayBuffer | ArrayBufferView, b: ArrayBuffer | ArrayBufferView): boolean;&#10;}&#10;/**&#10; * The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)&#10; */&#10;declare abstract class CryptoKey {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/type) */&#10;    readonly type: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/extractable) */&#10;    readonly extractable: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/algorithm) */&#10;    readonly algorithm: CryptoKeyKeyAlgorithm | CryptoKeyAesKeyAlgorithm | CryptoKeyHmacKeyAlgorithm | CryptoKeyRsaKeyAlgorithm | CryptoKeyEllipticKeyAlgorithm | CryptoKeyArbitraryKeyAlgorithm;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/usages) */&#10;    readonly usages: string[];&#10;}&#10;interface CryptoKeyPair {&#10;    publicKey: CryptoKey;&#10;    privateKey: CryptoKey;&#10;}&#10;interface JsonWebKey {&#10;    kty: string;&#10;    use?: string;&#10;    key_ops?: string[];&#10;    alg?: string;&#10;    ext?: boolean;&#10;    crv?: string;&#10;    x?: string;&#10;    y?: string;&#10;    d?: string;&#10;    n?: string;&#10;    e?: string;&#10;    p?: string;&#10;    q?: string;&#10;    dp?: string;&#10;    dq?: string;&#10;    qi?: string;&#10;    oth?: RsaOtherPrimesInfo[];&#10;    k?: string;&#10;}&#10;interface RsaOtherPrimesInfo {&#10;    r?: string;&#10;    d?: string;&#10;    t?: string;&#10;}&#10;interface SubtleCryptoDeriveKeyAlgorithm {&#10;    name: string;&#10;    salt?: (ArrayBuffer | ArrayBufferView);&#10;    iterations?: number;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    $public?: CryptoKey;&#10;    info?: (ArrayBuffer | ArrayBufferView);&#10;}&#10;interface SubtleCryptoEncryptAlgorithm {&#10;    name: string;&#10;    iv?: (ArrayBuffer | ArrayBufferView);&#10;    additionalData?: (ArrayBuffer | ArrayBufferView);&#10;    tagLength?: number;&#10;    counter?: (ArrayBuffer | ArrayBufferView);&#10;    length?: number;&#10;    label?: (ArrayBuffer | ArrayBufferView);&#10;}&#10;interface SubtleCryptoGenerateKeyAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    modulusLength?: number;&#10;    publicExponent?: (ArrayBuffer | ArrayBufferView);&#10;    length?: number;&#10;    namedCurve?: string;&#10;}&#10;interface SubtleCryptoHashAlgorithm {&#10;    name: string;&#10;}&#10;interface SubtleCryptoImportKeyAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    length?: number;&#10;    namedCurve?: string;&#10;    compressed?: boolean;&#10;}&#10;interface SubtleCryptoSignAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    dataLength?: number;&#10;    saltLength?: number;&#10;}&#10;interface CryptoKeyKeyAlgorithm {&#10;    name: string;&#10;}&#10;interface CryptoKeyAesKeyAlgorithm {&#10;    name: string;&#10;    length: number;&#10;}&#10;interface CryptoKeyHmacKeyAlgorithm {&#10;    name: string;&#10;    hash: CryptoKeyKeyAlgorithm;&#10;    length: number;&#10;}&#10;interface CryptoKeyRsaKeyAlgorithm {&#10;    name: string;&#10;    modulusLength: number;&#10;    publicExponent: ArrayBuffer | ArrayBufferView;&#10;    hash?: CryptoKeyKeyAlgorithm;&#10;}&#10;interface CryptoKeyEllipticKeyAlgorithm {&#10;    name: string;&#10;    namedCurve: string;&#10;}&#10;interface CryptoKeyArbitraryKeyAlgorithm {&#10;    name: string;&#10;    hash?: CryptoKeyKeyAlgorithm;&#10;    namedCurve?: string;&#10;    length?: number;&#10;}&#10;declare class DigestStream extends WritableStream&lt;ArrayBuffer | ArrayBufferView&gt; {&#10;    constructor(algorithm: string | SubtleCryptoHashAlgorithm);&#10;    readonly digest: Promise&lt;ArrayBuffer&gt;;&#10;    get bytesWritten(): number | bigint;&#10;}&#10;/**&#10; * A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)&#10; */&#10;declare class TextDecoder {&#10;    constructor(label?: string, options?: TextDecoderConstructorOptions);&#10;    /**&#10;     * Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented input. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.&#10;     *&#10;     * ```&#10;     * var string = &quot;&quot;, decoder = new TextDecoder(encoding), buffer;&#10;     * while(buffer = next_chunk()) {&#10;     *   string += decoder.decode(buffer, {stream:true});&#10;     * }&#10;     * string += decoder.decode(); // end-of-queue&#10;     * ```&#10;     *&#10;     * If the error mode is &quot;fatal&quot; and encoding's decoder returns error, throws a TypeError.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder/decode)&#10;     */&#10;    decode(input?: (ArrayBuffer | ArrayBufferView), options?: TextDecoderDecodeOptions): string;&#10;    get encoding(): string;&#10;    get fatal(): boolean;&#10;    get ignoreBOM(): boolean;&#10;}&#10;/**&#10; * TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)&#10; */&#10;declare class TextEncoder {&#10;    constructor();&#10;    /**&#10;     * Returns the result of running UTF-8's encoder.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encode)&#10;     */&#10;    encode(input?: string): Uint8Array;&#10;    /**&#10;     * Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encodeInto)&#10;     */&#10;    encodeInto(input: string, buffer: ArrayBuffer | ArrayBufferView): TextEncoderEncodeIntoResult;&#10;    get encoding(): string;&#10;}&#10;interface TextDecoderConstructorOptions {&#10;    fatal: boolean;&#10;    ignoreBOM: boolean;&#10;}&#10;interface TextDecoderDecodeOptions {&#10;    stream: boolean;&#10;}&#10;interface TextEncoderEncodeIntoResult {&#10;    read: number;&#10;    written: number;&#10;}&#10;/**&#10; * Events providing information related to errors in scripts or in files.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)&#10; */&#10;declare class ErrorEvent extends Event {&#10;    constructor(type: string, init?: ErrorEventErrorEventInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/filename) */&#10;    get filename(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/message) */&#10;    get message(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/lineno) */&#10;    get lineno(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/colno) */&#10;    get colno(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/error) */&#10;    get error(): any;&#10;}&#10;interface ErrorEventErrorEventInit {&#10;    message?: string;&#10;    filename?: string;&#10;    lineno?: number;&#10;    colno?: number;&#10;    error?: any;&#10;}&#10;/**&#10; * A message received by a target object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)&#10; */&#10;declare class MessageEvent extends Event {&#10;    constructor(type: string, initializer: MessageEventInit);&#10;    /**&#10;     * Returns the data of the message.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/data)&#10;     */&#10;    readonly data: any;&#10;    /**&#10;     * Returns the origin of the message, for server-sent events and cross-document messaging.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/origin)&#10;     */&#10;    readonly origin: string | null;&#10;    /**&#10;     * Returns the last event ID string, for server-sent events.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/lastEventId)&#10;     */&#10;    readonly lastEventId: string;&#10;    /**&#10;     * Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/source)&#10;     */&#10;    readonly source: MessagePort | null;&#10;    /**&#10;     * Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/ports)&#10;     */&#10;    readonly ports: MessagePort[];&#10;}&#10;interface MessageEventInit {&#10;    data: ArrayBuffer | string;&#10;}&#10;/**&#10; * Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to &quot;multipart/form-data&quot;.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)&#10; */&#10;declare class FormData {&#10;    constructor();&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */&#10;    append(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */&#10;    append(name: string, value: Blob, filename?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/delete) */&#10;    delete(name: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/get) */&#10;    get(name: string): (File | string) | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/getAll) */&#10;    getAll(name: string): (File | string)[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/has) */&#10;    has(name: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */&#10;    set(name: string, value: Blob, filename?: string): void;&#10;    /* Returns an array of key, value pairs for every entry in the list. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: File | string&#10;    ]&gt;;&#10;    /* Returns a list of keys in the list. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns a list of values in the list. */&#10;    values(): IterableIterator&lt;(File | string)&gt;;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: File | string, key: string, parent: FormData) =&gt; void, thisArg?: This): void;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: File | string&#10;    ]&gt;;&#10;}&#10;interface ContentOptions {&#10;    html?: boolean;&#10;}&#10;declare class HTMLRewriter {&#10;    constructor();&#10;    on(selector: string, handlers: HTMLRewriterElementContentHandlers): HTMLRewriter;&#10;    onDocument(handlers: HTMLRewriterDocumentContentHandlers): HTMLRewriter;&#10;    transform(response: Response): Response;&#10;}&#10;interface HTMLRewriterElementContentHandlers {&#10;    element?(element: Element): void | Promise&lt;void&gt;;&#10;    comments?(comment: Comment): void | Promise&lt;void&gt;;&#10;    text?(element: Text): void | Promise&lt;void&gt;;&#10;}&#10;interface HTMLRewriterDocumentContentHandlers {&#10;    doctype?(doctype: Doctype): void | Promise&lt;void&gt;;&#10;    comments?(comment: Comment): void | Promise&lt;void&gt;;&#10;    text?(text: Text): void | Promise&lt;void&gt;;&#10;    end?(end: DocumentEnd): void | Promise&lt;void&gt;;&#10;}&#10;interface Doctype {&#10;    readonly name: string | null;&#10;    readonly publicId: string | null;&#10;    readonly systemId: string | null;&#10;}&#10;interface Element {&#10;    tagName: string;&#10;    readonly attributes: IterableIterator&lt;string[]&gt;;&#10;    readonly removed: boolean;&#10;    readonly namespaceURI: string;&#10;    getAttribute(name: string): string | null;&#10;    hasAttribute(name: string): boolean;&#10;    setAttribute(name: string, value: string): Element;&#10;    removeAttribute(name: string): Element;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    prepend(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    append(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    replace(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    remove(): Element;&#10;    removeAndKeepContent(): Element;&#10;    setInnerContent(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    onEndTag(handler: (tag: EndTag) =&gt; void | Promise&lt;void&gt;): void;&#10;}&#10;interface EndTag {&#10;    name: string;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;&#10;    remove(): EndTag;&#10;}&#10;interface Comment {&#10;    text: string;&#10;    readonly removed: boolean;&#10;    before(content: string, options?: ContentOptions): Comment;&#10;    after(content: string, options?: ContentOptions): Comment;&#10;    replace(content: string, options?: ContentOptions): Comment;&#10;    remove(): Comment;&#10;}&#10;interface Text {&#10;    readonly text: string;&#10;    readonly lastInTextNode: boolean;&#10;    readonly removed: boolean;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    replace(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    remove(): Text;&#10;}&#10;interface DocumentEnd {&#10;    append(content: string, options?: ContentOptions): DocumentEnd;&#10;}&#10;/**&#10; * This is the event type for fetch events dispatched on the service worker global scope. It contains information about the fetch, including the request and how the receiver will treat the response. It provides the event.respondWith() method, which allows us to provide a response to this fetch.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent)&#10; */&#10;declare abstract class FetchEvent extends ExtendableEvent {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/request) */&#10;    readonly request: Request;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/respondWith) */&#10;    respondWith(promise: Response | Promise&lt;Response&gt;): void;&#10;    passThroughOnException(): void;&#10;}&#10;type HeadersInit = Headers | Iterable&lt;Iterable&lt;string&gt;&gt; | Record&lt;string, string&gt;;&#10;/**&#10; * This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)&#10; */&#10;declare class Headers {&#10;    constructor(init?: HeadersInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/get) */&#10;    get(name: string): string | null;&#10;    getAll(name: string): string[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/getSetCookie) */&#10;    getSetCookie(): string[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/has) */&#10;    has(name: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/set) */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/append) */&#10;    append(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/delete) */&#10;    delete(name: string): void;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: string, key: string, parent: Headers) =&gt; void, thisArg?: This): void;&#10;    /* Returns an iterator allowing to go through all key/value pairs contained in this object. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;    /* Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */&#10;    values(): IterableIterator&lt;string&gt;;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;}&#10;type BodyInit = ReadableStream&lt;Uint8Array&gt; | string | ArrayBuffer | ArrayBufferView | Blob | URLSearchParams | FormData;&#10;declare abstract class Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body) */&#10;    get body(): ReadableStream | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */&#10;    get bodyUsed(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes) */&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/text) */&#10;    text(): Promise&lt;string&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/json) */&#10;    json&lt;T&gt;(): Promise&lt;T&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/formData) */&#10;    formData(): Promise&lt;FormData&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */&#10;    blob(): Promise&lt;Blob&gt;;&#10;}&#10;/**&#10; * This Fetch API interface represents the response to a request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)&#10; */&#10;declare var Response: {&#10;    prototype: Response;&#10;    new (body?: BodyInit | null, init?: ResponseInit): Response;&#10;    error(): Response;&#10;    redirect(url: string, status?: number): Response;&#10;    json(any: any, maybeInit?: (ResponseInit | Response)): Response;&#10;};&#10;/**&#10; * This Fetch API interface represents the response to a request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)&#10; */&#10;interface Response extends Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/clone) */&#10;    clone(): Response;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/status) */&#10;    status: number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/statusText) */&#10;    statusText: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/headers) */&#10;    headers: Headers;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/ok) */&#10;    ok: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/redirected) */&#10;    redirected: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/url) */&#10;    url: string;&#10;    webSocket: WebSocket | null;&#10;    cf: any | undefined;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/type) */&#10;    type: &quot;default&quot; | &quot;error&quot;;&#10;}&#10;interface ResponseInit {&#10;    status?: number;&#10;    statusText?: string;&#10;    headers?: HeadersInit;&#10;    cf?: any;&#10;    webSocket?: (WebSocket | null);&#10;    encodeBody?: &quot;automatic&quot; | &quot;manual&quot;;&#10;}&#10;type RequestInfo&lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt; = Request&lt;CfHostMetadata, Cf&gt; | string;&#10;/**&#10; * This Fetch API interface represents a resource request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)&#10; */&#10;declare var Request: {&#10;    prototype: Request;&#10;    new &lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt;(input: RequestInfo&lt;CfProperties&gt; | URL, init?: RequestInit&lt;Cf&gt;): Request&lt;CfHostMetadata, Cf&gt;;&#10;};&#10;/**&#10; * This Fetch API interface represents a resource request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)&#10; */&#10;interface Request&lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt; extends Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/clone) */&#10;    clone(): Request&lt;CfHostMetadata, Cf&gt;;&#10;    /**&#10;     * Returns request's HTTP method, which is &quot;GET&quot; by default.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/method)&#10;     */&#10;    method: string;&#10;    /**&#10;     * Returns the URL of request as a string.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/url)&#10;     */&#10;    url: string;&#10;    /**&#10;     * Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the &quot;Host&quot; header.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/headers)&#10;     */&#10;    headers: Headers;&#10;    /**&#10;     * Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/redirect)&#10;     */&#10;    redirect: string;&#10;    fetcher: Fetcher | null;&#10;    /**&#10;     * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/signal)&#10;     */&#10;    signal: AbortSignal;&#10;    cf: Cf | undefined;&#10;    /**&#10;     * Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/integrity)&#10;     */&#10;    integrity: string;&#10;    /**&#10;     * Returns a boolean indicating whether or not request can outlive the global in which it was created.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/keepalive)&#10;     */&#10;    keepalive: boolean;&#10;    /**&#10;     * Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/cache)&#10;     */&#10;    cache?: &quot;no-store&quot;;&#10;}&#10;interface RequestInit&lt;Cf = CfProperties&gt; {&#10;    /* A string to set request's method. */&#10;    method?: string;&#10;    /* A Headers object, an object literal, or an array of two-item arrays to set request's headers. */&#10;    headers?: HeadersInit;&#10;    /* A BodyInit object or null to set request's body. */&#10;    body?: BodyInit | null;&#10;    /* A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */&#10;    redirect?: string;&#10;    fetcher?: (Fetcher | null);&#10;    cf?: Cf;&#10;    /* A string indicating how the request will interact with the browser's cache to set request's cache. */&#10;    cache?: &quot;no-store&quot;;&#10;    /* A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */&#10;    integrity?: string;&#10;    /* An AbortSignal to set request's signal. */&#10;    signal?: (AbortSignal | null);&#10;    encodeResponseBody?: &quot;automatic&quot; | &quot;manual&quot;;&#10;}&#10;type Service&lt;T extends (new (...args: any[]) =&gt; Rpc.WorkerEntrypointBranded) | Rpc.WorkerEntrypointBranded | ExportedHandler&lt;any, any, any&gt; | undefined = undefined&gt; = T extends new (...args: any[]) =&gt; Rpc.WorkerEntrypointBranded ? Fetcher&lt;InstanceType&lt;T&gt;&gt; : T extends Rpc.WorkerEntrypointBranded ? Fetcher&lt;T&gt; : T extends Exclude&lt;Rpc.EntrypointBranded, Rpc.WorkerEntrypointBranded&gt; ? never : Fetcher&lt;undefined&gt;;&#10;type Fetcher&lt;T extends Rpc.EntrypointBranded | undefined = undefined, Reserved extends string = never&gt; = (T extends Rpc.EntrypointBranded ? Rpc.Provider&lt;T, Reserved | &quot;fetch&quot; | &quot;connect&quot;&gt; : unknown) &amp; {&#10;    fetch(input: RequestInfo | URL, init?: RequestInit): Promise&lt;Response&gt;;&#10;    connect(address: SocketAddress | string, options?: SocketOptions): Socket;&#10;};&#10;interface KVNamespaceListKey&lt;Metadata, Key extends string = string&gt; {&#10;    name: Key;&#10;    expiration?: number;&#10;    metadata?: Metadata;&#10;}&#10;type KVNamespaceListResult&lt;Metadata, Key extends string = string&gt; = {&#10;    list_complete: false;&#10;    keys: KVNamespaceListKey&lt;Metadata, Key&gt;[];&#10;    cursor: string;&#10;    cacheStatus: string | null;&#10;} | {&#10;    list_complete: true;&#10;    keys: KVNamespaceListKey&lt;Metadata, Key&gt;[];&#10;    cacheStatus: string | null;&#10;};&#10;interface KVNamespace&lt;Key extends string = string&gt; {&#10;    get(key: Key, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;string | null&gt;;&#10;    get(key: Key, type: &quot;text&quot;): Promise&lt;string | null&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Key, type: &quot;json&quot;): Promise&lt;ExpectedValue | null&gt;;&#10;    get(key: Key, type: &quot;arrayBuffer&quot;): Promise&lt;ArrayBuffer | null&gt;;&#10;    get(key: Key, type: &quot;stream&quot;): Promise&lt;ReadableStream | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;string | null&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Key, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;ExpectedValue | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;arrayBuffer&quot;&gt;): Promise&lt;ArrayBuffer | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;stream&quot;&gt;): Promise&lt;ReadableStream | null&gt;;&#10;    get(key: Array&lt;Key&gt;, type: &quot;text&quot;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;json&quot;): Promise&lt;Map&lt;string, ExpectedValue | null&gt;&gt;;&#10;    get(key: Array&lt;Key&gt;, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;Map&lt;string, ExpectedValue | null&gt;&gt;;&#10;    list&lt;Metadata = unknown&gt;(options?: KVNamespaceListOptions): Promise&lt;KVNamespaceListResult&lt;Metadata, Key&gt;&gt;;&#10;    put(key: Key, value: string | ArrayBuffer | ArrayBufferView | ReadableStream, options?: KVNamespacePutOptions): Promise&lt;void&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;text&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Key, type: &quot;json&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;arrayBuffer&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ArrayBuffer, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;stream&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ReadableStream, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;arrayBuffer&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ArrayBuffer, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;stream&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ReadableStream, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;text&quot;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;json&quot;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;&gt;;&#10;    delete(key: Key): Promise&lt;void&gt;;&#10;}&#10;interface KVNamespaceListOptions {&#10;    limit?: number;&#10;    prefix?: (string | null);&#10;    cursor?: (string | null);&#10;}&#10;interface KVNamespaceGetOptions&lt;Type&gt; {&#10;    type: Type;&#10;    cacheTtl?: number;&#10;}&#10;interface KVNamespacePutOptions {&#10;    expiration?: number;&#10;    expirationTtl?: number;&#10;    metadata?: (any | null);&#10;}&#10;interface KVNamespaceGetWithMetadataResult&lt;Value, Metadata&gt; {&#10;    value: Value | null;&#10;    metadata: Metadata | null;&#10;    cacheStatus: string | null;&#10;}&#10;type QueueContentType = &quot;text&quot; | &quot;bytes&quot; | &quot;json&quot; | &quot;v8&quot;;&#10;interface Queue&lt;Body = unknown&gt; {&#10;    send(message: Body, options?: QueueSendOptions): Promise&lt;void&gt;;&#10;    sendBatch(messages: Iterable&lt;MessageSendRequest&lt;Body&gt;&gt;, options?: QueueSendBatchOptions): Promise&lt;void&gt;;&#10;}&#10;interface QueueSendOptions {&#10;    contentType?: QueueContentType;&#10;    delaySeconds?: number;&#10;}&#10;interface QueueSendBatchOptions {&#10;    delaySeconds?: number;&#10;}&#10;interface MessageSendRequest&lt;Body = unknown&gt; {&#10;    body: Body;&#10;    contentType?: QueueContentType;&#10;    delaySeconds?: number;&#10;}&#10;interface QueueRetryOptions {&#10;    delaySeconds?: number;&#10;}&#10;interface Message&lt;Body = unknown&gt; {&#10;    readonly id: string;&#10;    readonly timestamp: Date;&#10;    readonly body: Body;&#10;    readonly attempts: number;&#10;    retry(options?: QueueRetryOptions): void;&#10;    ack(): void;&#10;}&#10;interface QueueEvent&lt;Body = unknown&gt; extends ExtendableEvent {&#10;    readonly messages: readonly Message&lt;Body&gt;[];&#10;    readonly queue: string;&#10;    retryAll(options?: QueueRetryOptions): void;&#10;    ackAll(): void;&#10;}&#10;interface MessageBatch&lt;Body = unknown&gt; {&#10;    readonly messages: readonly Message&lt;Body&gt;[];&#10;    readonly queue: string;&#10;    retryAll(options?: QueueRetryOptions): void;&#10;    ackAll(): void;&#10;}&#10;interface R2Error extends Error {&#10;    readonly name: string;&#10;    readonly code: number;&#10;    readonly message: string;&#10;    readonly action: string;&#10;    readonly stack: any;&#10;}&#10;interface R2ListOptions {&#10;    limit?: number;&#10;    prefix?: string;&#10;    cursor?: string;&#10;    delimiter?: string;&#10;    startAfter?: string;&#10;    include?: (&quot;httpMetadata&quot; | &quot;customMetadata&quot;)[];&#10;}&#10;declare abstract class R2Bucket {&#10;    head(key: string): Promise&lt;R2Object | null&gt;;&#10;    get(key: string, options: R2GetOptions &amp; {&#10;        onlyIf: R2Conditional | Headers;&#10;    }): Promise&lt;R2ObjectBody | R2Object | null&gt;;&#10;    get(key: string, options?: R2GetOptions): Promise&lt;R2ObjectBody | null&gt;;&#10;    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions &amp; {&#10;        onlyIf: R2Conditional | Headers;&#10;    }): Promise&lt;R2Object | null&gt;;&#10;    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions): Promise&lt;R2Object&gt;;&#10;    createMultipartUpload(key: string, options?: R2MultipartOptions): Promise&lt;R2MultipartUpload&gt;;&#10;    resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;&#10;    delete(keys: string | string[]): Promise&lt;void&gt;;&#10;    list(options?: R2ListOptions): Promise&lt;R2Objects&gt;;&#10;}&#10;interface R2MultipartUpload {&#10;    readonly key: string;&#10;    readonly uploadId: string;&#10;    uploadPart(partNumber: number, value: ReadableStream | (ArrayBuffer | ArrayBufferView) | string | Blob, options?: R2UploadPartOptions): Promise&lt;R2UploadedPart&gt;;&#10;    abort(): Promise&lt;void&gt;;&#10;    complete(uploadedParts: R2UploadedPart[]): Promise&lt;R2Object&gt;;&#10;}&#10;interface R2UploadedPart {&#10;    partNumber: number;&#10;    etag: string;&#10;}&#10;declare abstract class R2Object {&#10;    readonly key: string;&#10;    readonly version: string;&#10;    readonly size: number;&#10;    readonly etag: string;&#10;    readonly httpEtag: string;&#10;    readonly checksums: R2Checksums;&#10;    readonly uploaded: Date;&#10;    readonly httpMetadata?: R2HTTPMetadata;&#10;    readonly customMetadata?: Record&lt;string, string&gt;;&#10;    readonly range?: R2Range;&#10;    readonly storageClass: string;&#10;    readonly ssecKeyMd5?: string;&#10;    writeHttpMetadata(headers: Headers): void;&#10;}&#10;interface R2ObjectBody extends R2Object {&#10;    get body(): ReadableStream;&#10;    get bodyUsed(): boolean;&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    text(): Promise&lt;string&gt;;&#10;    json&lt;T&gt;(): Promise&lt;T&gt;;&#10;    blob(): Promise&lt;Blob&gt;;&#10;}&#10;type R2Range = {&#10;    offset: number;&#10;    length?: number;&#10;} | {&#10;    offset?: number;&#10;    length: number;&#10;} | {&#10;    suffix: number;&#10;};&#10;interface R2Conditional {&#10;    etagMatches?: string;&#10;    etagDoesNotMatch?: string;&#10;    uploadedBefore?: Date;&#10;    uploadedAfter?: Date;&#10;    secondsGranularity?: boolean;&#10;}&#10;interface R2GetOptions {&#10;    onlyIf?: (R2Conditional | Headers);&#10;    range?: (R2Range | Headers);&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2PutOptions {&#10;    onlyIf?: (R2Conditional | Headers);&#10;    httpMetadata?: (R2HTTPMetadata | Headers);&#10;    customMetadata?: Record&lt;string, string&gt;;&#10;    md5?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha1?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha256?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha384?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha512?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    storageClass?: string;&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2MultipartOptions {&#10;    httpMetadata?: (R2HTTPMetadata | Headers);&#10;    customMetadata?: Record&lt;string, string&gt;;&#10;    storageClass?: string;&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2Checksums {&#10;    readonly md5?: ArrayBuffer;&#10;    readonly sha1?: ArrayBuffer;&#10;    readonly sha256?: ArrayBuffer;&#10;    readonly sha384?: ArrayBuffer;&#10;    readonly sha512?: ArrayBuffer;&#10;    toJSON(): R2StringChecksums;&#10;}&#10;interface R2StringChecksums {&#10;    md5?: string;&#10;    sha1?: string;&#10;    sha256?: string;&#10;    sha384?: string;&#10;    sha512?: string;&#10;}&#10;interface R2HTTPMetadata {&#10;    contentType?: string;&#10;    contentLanguage?: string;&#10;    contentDisposition?: string;&#10;    contentEncoding?: string;&#10;    cacheControl?: string;&#10;    cacheExpiry?: Date;&#10;}&#10;type R2Objects = {&#10;    objects: R2Object[];&#10;    delimitedPrefixes: string[];&#10;} &amp; ({&#10;    truncated: true;&#10;    cursor: string;&#10;} | {&#10;    truncated: false;&#10;});&#10;interface R2UploadPartOptions {&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;declare abstract class ScheduledEvent extends ExtendableEvent {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;    noRetry(): void;&#10;}&#10;interface ScheduledController {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;    noRetry(): void;&#10;}&#10;interface QueuingStrategy&lt;T = any&gt; {&#10;    highWaterMark?: (number | bigint);&#10;    size?: (chunk: T) =&gt; number | bigint;&#10;}&#10;interface UnderlyingSink&lt;W = any&gt; {&#10;    type?: string;&#10;    start?: (controller: WritableStreamDefaultController) =&gt; void | Promise&lt;void&gt;;&#10;    write?: (chunk: W, controller: WritableStreamDefaultController) =&gt; void | Promise&lt;void&gt;;&#10;    abort?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    close?: () =&gt; void | Promise&lt;void&gt;;&#10;}&#10;interface UnderlyingByteSource {&#10;    type: &quot;bytes&quot;;&#10;    autoAllocateChunkSize?: number;&#10;    start?: (controller: ReadableByteStreamController) =&gt; void | Promise&lt;void&gt;;&#10;    pull?: (controller: ReadableByteStreamController) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;}&#10;interface UnderlyingSource&lt;R = any&gt; {&#10;    type?: &quot;&quot; | undefined;&#10;    start?: (controller: ReadableStreamDefaultController&lt;R&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    pull?: (controller: ReadableStreamDefaultController&lt;R&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    expectedLength?: (number | bigint);&#10;}&#10;interface Transformer&lt;I = any, O = any&gt; {&#10;    readableType?: string;&#10;    writableType?: string;&#10;    start?: (controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    transform?: (chunk: I, controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    flush?: (controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    expectedLength?: number;&#10;}&#10;interface StreamPipeOptions {&#10;    /**&#10;     * Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.&#10;     *&#10;     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.&#10;     *&#10;     * Errors and closures of the source and destination streams propagate as follows:&#10;     *&#10;     * An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.&#10;     *&#10;     * An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.&#10;     *&#10;     * When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.&#10;     *&#10;     * If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.&#10;     *&#10;     * The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.&#10;     */&#10;    preventClose?: boolean;&#10;    preventAbort?: boolean;&#10;    preventCancel?: boolean;&#10;    signal?: AbortSignal;&#10;}&#10;type ReadableStreamReadResult&lt;R = any&gt; = {&#10;    done: false;&#10;    value: R;&#10;} | {&#10;    done: true;&#10;    value?: undefined;&#10;};&#10;/**&#10; * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)&#10; */&#10;interface ReadableStream&lt;R = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/locked) */&#10;    get locked(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/cancel) */&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */&#10;    getReader(): ReadableStreamDefaultReader&lt;R&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */&#10;    getReader(options: ReadableStreamGetReaderOptions): ReadableStreamBYOBReader;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeThrough) */&#10;    pipeThrough&lt;T&gt;(transform: ReadableWritablePair&lt;T, R&gt;, options?: StreamPipeOptions): ReadableStream&lt;T&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeTo) */&#10;    pipeTo(destination: WritableStream&lt;R&gt;, options?: StreamPipeOptions): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/tee) */&#10;    tee(): [&#10;        ReadableStream&lt;R&gt;,&#10;        ReadableStream&lt;R&gt;&#10;    ];&#10;    values(options?: ReadableStreamValuesOptions): AsyncIterableIterator&lt;R&gt;;&#10;    [Symbol.asyncIterator](options?: ReadableStreamValuesOptions): AsyncIterableIterator&lt;R&gt;;&#10;}&#10;/**&#10; * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)&#10; */&#10;declare const ReadableStream: {&#10;    prototype: ReadableStream;&#10;    new (underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy&lt;Uint8Array&gt;): ReadableStream&lt;Uint8Array&gt;;&#10;    new &lt;R = any&gt;(underlyingSource?: UnderlyingSource&lt;R&gt;, strategy?: QueuingStrategy&lt;R&gt;): ReadableStream&lt;R&gt;;&#10;};&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */&#10;declare class ReadableStreamDefaultReader&lt;R = any&gt; {&#10;    constructor(stream: ReadableStream);&#10;    get closed(): Promise&lt;void&gt;;&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/read) */&#10;    read(): Promise&lt;ReadableStreamReadResult&lt;R&gt;&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/releaseLock) */&#10;    releaseLock(): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */&#10;declare class ReadableStreamBYOBReader {&#10;    constructor(stream: ReadableStream);&#10;    get closed(): Promise&lt;void&gt;;&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */&#10;    read&lt;T extends ArrayBufferView&gt;(view: T): Promise&lt;ReadableStreamReadResult&lt;T&gt;&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */&#10;    releaseLock(): void;&#10;    readAtLeast&lt;T extends ArrayBufferView&gt;(minElements: number, view: T): Promise&lt;ReadableStreamReadResult&lt;T&gt;&gt;;&#10;}&#10;interface ReadableStreamBYOBReaderReadableStreamBYOBReaderReadOptions {&#10;    min?: number;&#10;}&#10;interface ReadableStreamGetReaderOptions {&#10;    /**&#10;     * Creates a ReadableStreamBYOBReader and locks the stream to the new reader.&#10;     *&#10;     * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle &quot;bring your own buffer&quot; reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.&#10;     */&#10;    mode: &quot;byob&quot;;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */&#10;declare abstract class ReadableStreamBYOBRequest {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */&#10;    get view(): Uint8Array | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */&#10;    respond(bytesWritten: number): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */&#10;    respondWithNewView(view: ArrayBuffer | ArrayBufferView): void;&#10;    get atLeast(): number | null;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */&#10;declare abstract class ReadableStreamDefaultController&lt;R = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/close) */&#10;    close(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/enqueue) */&#10;    enqueue(chunk?: R): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/error) */&#10;    error(reason: any): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */&#10;declare abstract class ReadableByteStreamController {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/byobRequest) */&#10;    get byobRequest(): ReadableStreamBYOBRequest | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/close) */&#10;    close(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/enqueue) */&#10;    enqueue(chunk: ArrayBuffer | ArrayBufferView): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/error) */&#10;    error(reason: any): void;&#10;}&#10;/**&#10; * This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)&#10; */&#10;declare abstract class WritableStreamDefaultController {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/signal) */&#10;    get signal(): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/error) */&#10;    error(reason?: any): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */&#10;declare abstract class TransformStreamDefaultController&lt;O = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/enqueue) */&#10;    enqueue(chunk?: O): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/error) */&#10;    error(reason: any): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/terminate) */&#10;    terminate(): void;&#10;}&#10;interface ReadableWritablePair&lt;R = any, W = any&gt; {&#10;    /**&#10;     * Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.&#10;     *&#10;     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.&#10;     */&#10;    writable: WritableStream&lt;W&gt;;&#10;    readable: ReadableStream&lt;R&gt;;&#10;}&#10;/**&#10; * This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)&#10; */&#10;declare class WritableStream&lt;W = any&gt; {&#10;    constructor(underlyingSink?: UnderlyingSink, queuingStrategy?: QueuingStrategy);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/locked) */&#10;    get locked(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/abort) */&#10;    abort(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/close) */&#10;    close(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/getWriter) */&#10;    getWriter(): WritableStreamDefaultWriter&lt;W&gt;;&#10;}&#10;/**&#10; * This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the &lt; writer to the WritableStream ensuring that no other streams can write to the underlying sink.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)&#10; */&#10;declare class WritableStreamDefaultWriter&lt;W = any&gt; {&#10;    constructor(stream: WritableStream);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/closed) */&#10;    get closed(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/ready) */&#10;    get ready(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/abort) */&#10;    abort(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/close) */&#10;    close(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/write) */&#10;    write(chunk?: W): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/releaseLock) */&#10;    releaseLock(): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */&#10;declare class TransformStream&lt;I = any, O = any&gt; {&#10;    constructor(transformer?: Transformer&lt;I, O&gt;, writableStrategy?: QueuingStrategy&lt;I&gt;, readableStrategy?: QueuingStrategy&lt;O&gt;);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/readable) */&#10;    get readable(): ReadableStream&lt;O&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/writable) */&#10;    get writable(): WritableStream&lt;I&gt;;&#10;}&#10;declare class FixedLengthStream extends IdentityTransformStream {&#10;    constructor(expectedLength: number | bigint, queuingStrategy?: IdentityTransformStreamQueuingStrategy);&#10;}&#10;declare class IdentityTransformStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(queuingStrategy?: IdentityTransformStreamQueuingStrategy);&#10;}&#10;interface IdentityTransformStreamQueuingStrategy {&#10;    highWaterMark?: (number | bigint);&#10;}&#10;interface ReadableStreamValuesOptions {&#10;    preventCancel?: boolean;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */&#10;declare class CompressionStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(format: &quot;gzip&quot; | &quot;deflate&quot; | &quot;deflate-raw&quot;);&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */&#10;declare class DecompressionStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(format: &quot;gzip&quot; | &quot;deflate&quot; | &quot;deflate-raw&quot;);&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */&#10;declare class TextEncoderStream extends TransformStream&lt;string, Uint8Array&gt; {&#10;    constructor();&#10;    get encoding(): string;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */&#10;declare class TextDecoderStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, string&gt; {&#10;    constructor(label?: string, options?: TextDecoderStreamTextDecoderStreamInit);&#10;    get encoding(): string;&#10;    get fatal(): boolean;&#10;    get ignoreBOM(): boolean;&#10;}&#10;interface TextDecoderStreamTextDecoderStreamInit {&#10;    fatal?: boolean;&#10;    ignoreBOM?: boolean;&#10;}&#10;/**&#10; * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)&#10; */&#10;declare class ByteLengthQueuingStrategy implements QueuingStrategy&lt;ArrayBufferView&gt; {&#10;    constructor(init: QueuingStrategyInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/highWaterMark) */&#10;    get highWaterMark(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/size) */&#10;    get size(): (chunk?: any) =&gt; number;&#10;}&#10;/**&#10; * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)&#10; */&#10;declare class CountQueuingStrategy implements QueuingStrategy {&#10;    constructor(init: QueuingStrategyInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/highWaterMark) */&#10;    get highWaterMark(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/size) */&#10;    get size(): (chunk?: any) =&gt; number;&#10;}&#10;interface QueuingStrategyInit {&#10;    /**&#10;     * Creates a new ByteLengthQueuingStrategy with the provided high water mark.&#10;     *&#10;     * Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.&#10;     */&#10;    highWaterMark: number;&#10;}&#10;interface ScriptVersion {&#10;    id?: string;&#10;    tag?: string;&#10;    message?: string;&#10;}&#10;declare abstract class TailEvent extends ExtendableEvent {&#10;    readonly events: TraceItem[];&#10;    readonly traces: TraceItem[];&#10;}&#10;interface TraceItem {&#10;    readonly event: (TraceItemFetchEventInfo | TraceItemJsRpcEventInfo | TraceItemScheduledEventInfo | TraceItemAlarmEventInfo | TraceItemQueueEventInfo | TraceItemEmailEventInfo | TraceItemTailEventInfo | TraceItemCustomEventInfo | TraceItemHibernatableWebSocketEventInfo) | null;&#10;    readonly eventTimestamp: number | null;&#10;    readonly logs: TraceLog[];&#10;    readonly exceptions: TraceException[];&#10;    readonly diagnosticsChannelEvents: TraceDiagnosticChannelEvent[];&#10;    readonly scriptName: string | null;&#10;    readonly entrypoint?: string;&#10;    readonly scriptVersion?: ScriptVersion;&#10;    readonly dispatchNamespace?: string;&#10;    readonly scriptTags?: string[];&#10;    readonly outcome: string;&#10;    readonly executionModel: string;&#10;    readonly truncated: boolean;&#10;    readonly cpuTime: number;&#10;    readonly wallTime: number;&#10;}&#10;interface TraceItemAlarmEventInfo {&#10;    readonly scheduledTime: Date;&#10;}&#10;interface TraceItemCustomEventInfo {&#10;}&#10;interface TraceItemScheduledEventInfo {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;}&#10;interface TraceItemQueueEventInfo {&#10;    readonly queue: string;&#10;    readonly batchSize: number;&#10;}&#10;interface TraceItemEmailEventInfo {&#10;    readonly mailFrom: string;&#10;    readonly rcptTo: string;&#10;    readonly rawSize: number;&#10;}&#10;interface TraceItemTailEventInfo {&#10;    readonly consumedEvents: TraceItemTailEventInfoTailItem[];&#10;}&#10;interface TraceItemTailEventInfoTailItem {&#10;    readonly scriptName: string | null;&#10;}&#10;interface TraceItemFetchEventInfo {&#10;    readonly response?: TraceItemFetchEventInfoResponse;&#10;    readonly request: TraceItemFetchEventInfoRequest;&#10;}&#10;interface TraceItemFetchEventInfoRequest {&#10;    readonly cf?: any;&#10;    readonly headers: Record&lt;string, string&gt;;&#10;    readonly method: string;&#10;    readonly url: string;&#10;    getUnredacted(): TraceItemFetchEventInfoRequest;&#10;}&#10;interface TraceItemFetchEventInfoResponse {&#10;    readonly status: number;&#10;}&#10;interface TraceItemJsRpcEventInfo {&#10;    readonly rpcMethod: string;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfo {&#10;    readonly getWebSocketEvent: TraceItemHibernatableWebSocketEventInfoMessage | TraceItemHibernatableWebSocketEventInfoClose | TraceItemHibernatableWebSocketEventInfoError;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoMessage {&#10;    readonly webSocketEventType: string;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoClose {&#10;    readonly webSocketEventType: string;&#10;    readonly code: number;&#10;    readonly wasClean: boolean;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoError {&#10;    readonly webSocketEventType: string;&#10;}&#10;interface TraceLog {&#10;    readonly timestamp: number;&#10;    readonly level: string;&#10;    readonly message: any;&#10;}&#10;interface TraceException {&#10;    readonly timestamp: number;&#10;    readonly message: string;&#10;    readonly name: string;&#10;    readonly stack?: string;&#10;}&#10;interface TraceDiagnosticChannelEvent {&#10;    readonly timestamp: number;&#10;    readonly channel: string;&#10;    readonly message: any;&#10;}&#10;interface TraceMetrics {&#10;    readonly cpuTime: number;&#10;    readonly wallTime: number;&#10;}&#10;interface UnsafeTraceMetrics {&#10;    fromTrace(item: TraceItem): TraceMetrics;&#10;}&#10;/**&#10; * The URL interface represents an object providing static methods used for creating object URLs.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)&#10; */&#10;declare class URL {&#10;    constructor(url: string | URL, base?: string | URL);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/origin) */&#10;    get origin(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */&#10;    get href(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */&#10;    set href(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */&#10;    get protocol(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */&#10;    set protocol(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */&#10;    get username(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */&#10;    set username(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */&#10;    get password(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */&#10;    set password(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */&#10;    get host(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */&#10;    set host(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */&#10;    get hostname(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */&#10;    set hostname(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */&#10;    get port(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */&#10;    set port(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */&#10;    get pathname(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */&#10;    set pathname(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */&#10;    get search(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */&#10;    set search(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */&#10;    get hash(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */&#10;    set hash(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/searchParams) */&#10;    get searchParams(): URLSearchParams;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/toJSON) */&#10;    toJSON(): string;&#10;    /*function toString() { [native code] }*/&#10;    toString(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/canParse_static) */&#10;    static canParse(url: string, base?: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/parse_static) */&#10;    static parse(url: string, base?: string): URL | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/createObjectURL_static) */&#10;    static createObjectURL(object: File | Blob): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/revokeObjectURL_static) */&#10;    static revokeObjectURL(object_url: string): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */&#10;declare class URLSearchParams {&#10;    constructor(init?: (Iterable&lt;Iterable&lt;string&gt;&gt; | Record&lt;string, string&gt; | string));&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/size) */&#10;    get size(): number;&#10;    /**&#10;     * Appends a specified key/value pair as a new search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/append)&#10;     */&#10;    append(name: string, value: string): void;&#10;    /**&#10;     * Deletes the given search parameter, and its associated value, from the list of all search parameters.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/delete)&#10;     */&#10;    delete(name: string, value?: string): void;&#10;    /**&#10;     * Returns the first value associated to the given search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/get)&#10;     */&#10;    get(name: string): string | null;&#10;    /**&#10;     * Returns all the values association with a given search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/getAll)&#10;     */&#10;    getAll(name: string): string[];&#10;    /**&#10;     * Returns a Boolean indicating if such a search parameter exists.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/has)&#10;     */&#10;    has(name: string, value?: string): boolean;&#10;    /**&#10;     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/set)&#10;     */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/sort) */&#10;    sort(): void;&#10;    /* Returns an array of key, value pairs for every entry in the search params. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;    /* Returns a list of keys in the search params. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns a list of values in the search params. */&#10;    values(): IterableIterator&lt;string&gt;;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: string, key: string, parent: URLSearchParams) =&gt; void, thisArg?: This): void;&#10;    /*function toString() { [native code] } Returns a string containing a query string suitable for use in a URL. Does not include the question mark. */&#10;    toString(): string;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;}&#10;declare class URLPattern {&#10;    constructor(input?: (string | URLPatternInit), baseURL?: (string | URLPatternOptions), patternOptions?: URLPatternOptions);&#10;    get protocol(): string;&#10;    get username(): string;&#10;    get password(): string;&#10;    get hostname(): string;&#10;    get port(): string;&#10;    get pathname(): string;&#10;    get search(): string;&#10;    get hash(): string;&#10;    get hasRegExpGroups(): boolean;&#10;    test(input?: (string | URLPatternInit), baseURL?: string): boolean;&#10;    exec(input?: (string | URLPatternInit), baseURL?: string): URLPatternResult | null;&#10;}&#10;interface URLPatternInit {&#10;    protocol?: string;&#10;    username?: string;&#10;    password?: string;&#10;    hostname?: string;&#10;    port?: string;&#10;    pathname?: string;&#10;    search?: string;&#10;    hash?: string;&#10;    baseURL?: string;&#10;}&#10;interface URLPatternComponentResult {&#10;    input: string;&#10;    groups: Record&lt;string, string&gt;;&#10;}&#10;interface URLPatternResult {&#10;    inputs: (string | URLPatternInit)[];&#10;    protocol: URLPatternComponentResult;&#10;    username: URLPatternComponentResult;&#10;    password: URLPatternComponentResult;&#10;    hostname: URLPatternComponentResult;&#10;    port: URLPatternComponentResult;&#10;    pathname: URLPatternComponentResult;&#10;    search: URLPatternComponentResult;&#10;    hash: URLPatternComponentResult;&#10;}&#10;interface URLPatternOptions {&#10;    ignoreCase?: boolean;&#10;}&#10;/**&#10; * A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)&#10; */&#10;declare class CloseEvent extends Event {&#10;    constructor(type: string, initializer?: CloseEventInit);&#10;    /**&#10;     * Returns the WebSocket connection close code provided by the server.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/code)&#10;     */&#10;    readonly code: number;&#10;    /**&#10;     * Returns the WebSocket connection close reason provided by the server.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/reason)&#10;     */&#10;    readonly reason: string;&#10;    /**&#10;     * Returns true if the connection closed cleanly; false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/wasClean)&#10;     */&#10;    readonly wasClean: boolean;&#10;}&#10;interface CloseEventInit {&#10;    code?: number;&#10;    reason?: string;&#10;    wasClean?: boolean;&#10;}&#10;type WebSocketEventMap = {&#10;    close: CloseEvent;&#10;    message: MessageEvent;&#10;    open: Event;&#10;    error: ErrorEvent;&#10;};&#10;/**&#10; * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)&#10; */&#10;declare var WebSocket: {&#10;    prototype: WebSocket;&#10;    new (url: string, protocols?: (string[] | string)): WebSocket;&#10;    readonly READY_STATE_CONNECTING: number;&#10;    readonly CONNECTING: number;&#10;    readonly READY_STATE_OPEN: number;&#10;    readonly OPEN: number;&#10;    readonly READY_STATE_CLOSING: number;&#10;    readonly CLOSING: number;&#10;    readonly READY_STATE_CLOSED: number;&#10;    readonly CLOSED: number;&#10;};&#10;/**&#10; * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)&#10; */&#10;interface WebSocket extends EventTarget&lt;WebSocketEventMap&gt; {&#10;    accept(): void;&#10;    /**&#10;     * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/send)&#10;     */&#10;    send(message: (ArrayBuffer | ArrayBufferView) | string): void;&#10;    /**&#10;     * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/close)&#10;     */&#10;    close(code?: number, reason?: string): void;&#10;    serializeAttachment(attachment: any): void;&#10;    deserializeAttachment(): any | null;&#10;    /**&#10;     * Returns the state of the WebSocket object's connection. It can have the values described below.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/readyState)&#10;     */&#10;    readyState: number;&#10;    /**&#10;     * Returns the URL that was used to establish the WebSocket connection.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/url)&#10;     */&#10;    url: string | null;&#10;    /**&#10;     * Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/protocol)&#10;     */&#10;    protocol: string | null;&#10;    /**&#10;     * Returns the extensions selected by the server, if any.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/extensions)&#10;     */&#10;    extensions: string | null;&#10;}&#10;declare const WebSocketPair: {&#10;    new (): {&#10;        0: WebSocket;&#10;        1: WebSocket;&#10;    };&#10;};&#10;interface SqlStorage {&#10;    exec&lt;T extends Record&lt;string, SqlStorageValue&gt;&gt;(query: string, ...bindings: any[]): SqlStorageCursor&lt;T&gt;;&#10;    get databaseSize(): number;&#10;    Cursor: typeof SqlStorageCursor;&#10;    Statement: typeof SqlStorageStatement;&#10;}&#10;declare abstract class SqlStorageStatement {&#10;}&#10;type SqlStorageValue = ArrayBuffer | string | number | null;&#10;declare abstract class SqlStorageCursor&lt;T extends Record&lt;string, SqlStorageValue&gt;&gt; {&#10;    next(): {&#10;        done?: false;&#10;        value: T;&#10;    } | {&#10;        done: true;&#10;        value?: never;&#10;    };&#10;    toArray(): T[];&#10;    one(): T;&#10;    raw&lt;U extends SqlStorageValue[]&gt;(): IterableIterator&lt;U&gt;;&#10;    columnNames: string[];&#10;    get rowsRead(): number;&#10;    get rowsWritten(): number;&#10;    [Symbol.iterator](): IterableIterator&lt;T&gt;;&#10;}&#10;interface SecretsStoreSecret {&#10;    /**&#10;     * Get a secret from the Secrets Store, returning a string of the secret value&#10;     * if it exists, or throws an error if it does not exist&#10;     */&#10;    get(): Promise&lt;string&gt;;&#10;}&#10;declare module &quot;cloudflare:pipelines&quot; {&#10;    export abstract class PipelineTransformationEntrypoint&lt;Env = unknown, I extends PipelineRecord = PipelineRecord, O extends PipelineRecord = PipelineRecord&gt; {&#10;        protected env: Env;&#10;        protected ctx: ExecutionContext;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        /**&#10;         * run recieves an array of PipelineRecord which can be&#10;         * transformed and returned to the pipeline&#10;         * @param records Incoming records from the pipeline to be transformed&#10;         * @param metadata Information about the specific pipeline calling the transformation entrypoint&#10;         * @returns A promise containing the transformed PipelineRecord array&#10;         */&#10;        public run(records: I[], metadata: PipelineBatchMetadata): Promise&lt;O[]&gt;;&#10;    }&#10;    export type PipelineRecord = Record&lt;string, unknown&gt;;&#10;    export type PipelineBatchMetadata = {&#10;        pipelineId: string;&#10;        pipelineName: string;&#10;    };&#10;    export interface Pipeline&lt;T extends PipelineRecord = PipelineRecord&gt; {&#10;        /**&#10;         * The Pipeline interface represents the type of a binding to a Pipeline&#10;         *&#10;         * @param records The records to send to the pipeline&#10;         */&#10;        send(records: T[]): Promise&lt;void&gt;;&#10;    }&#10;}&#10;// PubSubMessage represents an incoming PubSub message.&#10;// The message includes metadata about the broker, the client, and the payload&#10;// itself.&#10;// https://developers.cloudflare.com/pub-sub/&#10;interface PubSubMessage {&#10;    // Message ID&#10;    readonly mid: number;&#10;    // MQTT broker FQDN in the form mqtts://BROKER.NAMESPACE.cloudflarepubsub.com:PORT&#10;    readonly broker: string;&#10;    // The MQTT topic the message was sent on.&#10;    readonly topic: string;&#10;    // The client ID of the client that published this message.&#10;    readonly clientId: string;&#10;    // The unique identifier (JWT ID) used by the client to authenticate, if token&#10;    // auth was used.&#10;    readonly jti?: string;&#10;    // A Unix timestamp (seconds from Jan 1, 1970), set when the Pub/Sub Broker&#10;    // received the message from the client.&#10;    readonly receivedAt: number;&#10;    // An (optional) string with the MIME type of the payload, if set by the&#10;    // client.&#10;    readonly contentType: string;&#10;    // Set to 1 when the payload is a UTF-8 string&#10;    // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901063&#10;    readonly payloadFormatIndicator: number;&#10;    // Pub/Sub (MQTT) payloads can be UTF-8 strings, or byte arrays.&#10;    // You can use payloadFormatIndicator to inspect this before decoding.&#10;    payload: string | Uint8Array;&#10;}&#10;// JsonWebKey extended by kid parameter&#10;interface JsonWebKeyWithKid extends JsonWebKey {&#10;    // Key Identifier of the JWK&#10;    readonly kid: string;&#10;}&#10;interface RateLimitOptions {&#10;    key: string;&#10;}&#10;interface RateLimitOutcome {&#10;    success: boolean;&#10;}&#10;interface RateLimit {&#10;    /**&#10;     * Rate limit a request based on the provided options.&#10;     * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/&#10;     * @returns A promise that resolves with the outcome of the rate limit.&#10;     */&#10;    limit(options: RateLimitOptions): Promise&lt;RateLimitOutcome&gt;;&#10;}&#10;// Namespace for RPC utility types. Unfortunately, we can't use a `module` here as these types need&#10;// to referenced by `Fetcher`. This is included in the &quot;importable&quot; version of the types which&#10;// strips all `module` blocks.&#10;declare namespace Rpc {&#10;    // Branded types for identifying `WorkerEntrypoint`/`DurableObject`/`Target`s.&#10;    // TypeScript uses *structural* typing meaning anything with the same shape as type `T` is a `T`.&#10;    // For the classes exported by `cloudflare:workers` we want *nominal* typing (i.e. we only want to&#10;    // accept `WorkerEntrypoint` from `cloudflare:workers`, not any other class with the same shape)&#10;    export const __RPC_STUB_BRAND: '__RPC_STUB_BRAND';&#10;    export const __RPC_TARGET_BRAND: '__RPC_TARGET_BRAND';&#10;    export const __WORKER_ENTRYPOINT_BRAND: '__WORKER_ENTRYPOINT_BRAND';&#10;    export const __DURABLE_OBJECT_BRAND: '__DURABLE_OBJECT_BRAND';&#10;    export const __WORKFLOW_ENTRYPOINT_BRAND: '__WORKFLOW_ENTRYPOINT_BRAND';&#10;    export interface RpcTargetBranded {&#10;        [__RPC_TARGET_BRAND]: never;&#10;    }&#10;    export interface WorkerEntrypointBranded {&#10;        [__WORKER_ENTRYPOINT_BRAND]: never;&#10;    }&#10;    export interface DurableObjectBranded {&#10;        [__DURABLE_OBJECT_BRAND]: never;&#10;    }&#10;    export interface WorkflowEntrypointBranded {&#10;        [__WORKFLOW_ENTRYPOINT_BRAND]: never;&#10;    }&#10;    export type EntrypointBranded = WorkerEntrypointBranded | DurableObjectBranded | WorkflowEntrypointBranded;&#10;    // Types that can be used through `Stub`s&#10;    export type Stubable = RpcTargetBranded | ((...args: any[]) =&gt; any);&#10;    // Types that can be passed over RPC&#10;    // The reason for using a generic type here is to build a serializable subset of structured&#10;    //   cloneable composite types. This allows types defined with the &quot;interface&quot; keyword to pass the&#10;    //   serializable check as well. Otherwise, only types defined with the &quot;type&quot; keyword would pass.&#10;    type Serializable&lt;T&gt; =&#10;    // Structured cloneables&#10;    BaseType&#10;    // Structured cloneable composites&#10;     | Map&lt;T extends Map&lt;infer U, unknown&gt; ? Serializable&lt;U&gt; : never, T extends Map&lt;unknown, infer U&gt; ? Serializable&lt;U&gt; : never&gt; | Set&lt;T extends Set&lt;infer U&gt; ? Serializable&lt;U&gt; : never&gt; | ReadonlyArray&lt;T extends ReadonlyArray&lt;infer U&gt; ? Serializable&lt;U&gt; : never&gt; | {&#10;        [K in keyof T]: K extends number | string ? Serializable&lt;T[K]&gt; : never;&#10;    }&#10;    // Special types&#10;     | Stub&lt;Stubable&gt;&#10;    // Serialized as stubs, see `Stubify`&#10;     | Stubable;&#10;    // Base type for all RPC stubs, including common memory management methods.&#10;    // `T` is used as a marker type for unwrapping `Stub`s later.&#10;    interface StubBase&lt;T extends Stubable&gt; extends Disposable {&#10;        [__RPC_STUB_BRAND]: T;&#10;        dup(): this;&#10;    }&#10;    export type Stub&lt;T extends Stubable&gt; = Provider&lt;T&gt; &amp; StubBase&lt;T&gt;;&#10;    // This represents all the types that can be sent as-is over an RPC boundary&#10;    type BaseType = void | undefined | null | boolean | number | bigint | string | TypedArray | ArrayBuffer | DataView | Date | Error | RegExp | ReadableStream&lt;Uint8Array&gt; | WritableStream&lt;Uint8Array&gt; | Request | Response | Headers;&#10;    // Recursively rewrite all `Stubable` types with `Stub`s&#10;    // prettier-ignore&#10;    type Stubify&lt;T&gt; = T extends Stubable ? Stub&lt;T&gt; : T extends Map&lt;infer K, infer V&gt; ? Map&lt;Stubify&lt;K&gt;, Stubify&lt;V&gt;&gt; : T extends Set&lt;infer V&gt; ? Set&lt;Stubify&lt;V&gt;&gt; : T extends Array&lt;infer V&gt; ? Array&lt;Stubify&lt;V&gt;&gt; : T extends ReadonlyArray&lt;infer V&gt; ? ReadonlyArray&lt;Stubify&lt;V&gt;&gt; : T extends BaseType ? T : T extends {&#10;        [key: string | number]: any;&#10;    } ? {&#10;        [K in keyof T]: Stubify&lt;T[K]&gt;;&#10;    } : T;&#10;    // Recursively rewrite all `Stub&lt;T&gt;`s with the corresponding `T`s.&#10;    // Note we use `StubBase` instead of `Stub` here to avoid circular dependencies:&#10;    // `Stub` depends on `Provider`, which depends on `Unstubify`, which would depend on `Stub`.&#10;    // prettier-ignore&#10;    type Unstubify&lt;T&gt; = T extends StubBase&lt;infer V&gt; ? V : T extends Map&lt;infer K, infer V&gt; ? Map&lt;Unstubify&lt;K&gt;, Unstubify&lt;V&gt;&gt; : T extends Set&lt;infer V&gt; ? Set&lt;Unstubify&lt;V&gt;&gt; : T extends Array&lt;infer V&gt; ? Array&lt;Unstubify&lt;V&gt;&gt; : T extends ReadonlyArray&lt;infer V&gt; ? ReadonlyArray&lt;Unstubify&lt;V&gt;&gt; : T extends BaseType ? T : T extends {&#10;        [key: string | number]: unknown;&#10;    } ? {&#10;        [K in keyof T]: Unstubify&lt;T[K]&gt;;&#10;    } : T;&#10;    type UnstubifyAll&lt;A extends any[]&gt; = {&#10;        [I in keyof A]: Unstubify&lt;A[I]&gt;;&#10;    };&#10;    // Utility type for adding `Provider`/`Disposable`s to `object` types only.&#10;    // Note `unknown &amp; T` is equivalent to `T`.&#10;    type MaybeProvider&lt;T&gt; = T extends object ? Provider&lt;T&gt; : unknown;&#10;    type MaybeDisposable&lt;T&gt; = T extends object ? Disposable : unknown;&#10;    // Type for method return or property on an RPC interface.&#10;    // - Stubable types are replaced by stubs.&#10;    // - Serializable types are passed by value, with stubable types replaced by stubs&#10;    //   and a top-level `Disposer`.&#10;    // Everything else can't be passed over PRC.&#10;    // Technically, we use custom thenables here, but they quack like `Promise`s.&#10;    // Intersecting with `(Maybe)Provider` allows pipelining.&#10;    // prettier-ignore&#10;    type Result&lt;R&gt; = R extends Stubable ? Promise&lt;Stub&lt;R&gt;&gt; &amp; Provider&lt;R&gt; : R extends Serializable&lt;R&gt; ? Promise&lt;Stubify&lt;R&gt; &amp; MaybeDisposable&lt;R&gt;&gt; &amp; MaybeProvider&lt;R&gt; : never;&#10;    // Type for method or property on an RPC interface.&#10;    // For methods, unwrap `Stub`s in parameters, and rewrite returns to be `Result`s.&#10;    // Unwrapping `Stub`s allows calling with `Stubable` arguments.&#10;    // For properties, rewrite types to be `Result`s.&#10;    // In each case, unwrap `Promise`s.&#10;    type MethodOrProperty&lt;V&gt; = V extends (...args: infer P) =&gt; infer R ? (...args: UnstubifyAll&lt;P&gt;) =&gt; Result&lt;Awaited&lt;R&gt;&gt; : Result&lt;Awaited&lt;V&gt;&gt;;&#10;    // Type for the callable part of an `Provider` if `T` is callable.&#10;    // This is intersected with methods/properties.&#10;    type MaybeCallableProvider&lt;T&gt; = T extends (...args: any[]) =&gt; any ? MethodOrProperty&lt;T&gt; : unknown;&#10;    // Base type for all other types providing RPC-like interfaces.&#10;    // Rewrites all methods/properties to be `MethodOrProperty`s, while preserving callable types.&#10;    // `Reserved` names (e.g. stub method names like `dup()`) and symbols can't be accessed over RPC.&#10;    // prettier-ignore&#10;    type Provider&lt;T extends object, Reserved extends string = never&gt; = MaybeCallableProvider&lt;T&gt; &amp; {&#10;        [K in Exclude&lt;keyof T, Reserved | symbol | keyof StubBase&lt;never&gt;&gt;]: MethodOrProperty&lt;T[K]&gt;;&#10;    };&#10;}&#10;declare namespace Cloudflare {&#10;    interface Env {&#10;    }&#10;}&#10;declare module &quot;cloudflare:workers&quot; {&#10;    export type RpcStub&lt;T extends Rpc.Stubable&gt; = Rpc.Stub&lt;T&gt;;&#10;    export const RpcStub: {&#10;        new &lt;T extends Rpc.Stubable&gt;(value: T): Rpc.Stub&lt;T&gt;;&#10;    };&#10;    export abstract class RpcTarget implements Rpc.RpcTargetBranded {&#10;        [Rpc.__RPC_TARGET_BRAND]: never;&#10;    }&#10;    // `protected` fields don't appear in `keyof`s, so can't be accessed over RPC&#10;    export abstract class WorkerEntrypoint&lt;Env = unknown&gt; implements Rpc.WorkerEntrypointBranded {&#10;        [Rpc.__WORKER_ENTRYPOINT_BRAND]: never;&#10;        protected ctx: ExecutionContext;&#10;        protected env: Env;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        fetch?(request: Request): Response | Promise&lt;Response&gt;;&#10;        tail?(events: TraceItem[]): void | Promise&lt;void&gt;;&#10;        trace?(traces: TraceItem[]): void | Promise&lt;void&gt;;&#10;        scheduled?(controller: ScheduledController): void | Promise&lt;void&gt;;&#10;        queue?(batch: MessageBatch&lt;unknown&gt;): void | Promise&lt;void&gt;;&#10;        test?(controller: TestController): void | Promise&lt;void&gt;;&#10;    }&#10;    export abstract class DurableObject&lt;Env = unknown&gt; implements Rpc.DurableObjectBranded {&#10;        [Rpc.__DURABLE_OBJECT_BRAND]: never;&#10;        protected ctx: DurableObjectState;&#10;        protected env: Env;&#10;        constructor(ctx: DurableObjectState, env: Env);&#10;        fetch?(request: Request): Response | Promise&lt;Response&gt;;&#10;        alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise&lt;void&gt;;&#10;        webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise&lt;void&gt;;&#10;        webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise&lt;void&gt;;&#10;        webSocketError?(ws: WebSocket, error: unknown): void | Promise&lt;void&gt;;&#10;    }&#10;    export type WorkflowDurationLabel = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';&#10;    export type WorkflowSleepDuration = `${number} ${WorkflowDurationLabel}${'s' | ''}` | number;&#10;    export type WorkflowDelayDuration = WorkflowSleepDuration;&#10;    export type WorkflowTimeoutDuration = WorkflowSleepDuration;&#10;    export type WorkflowRetentionDuration = WorkflowSleepDuration;&#10;    export type WorkflowBackoff = 'constant' | 'linear' | 'exponential';&#10;    export type WorkflowStepConfig = {&#10;        retries?: {&#10;            limit: number;&#10;            delay: WorkflowDelayDuration | number;&#10;            backoff?: WorkflowBackoff;&#10;        };&#10;        timeout?: WorkflowTimeoutDuration | number;&#10;    };&#10;    export type WorkflowEvent&lt;T&gt; = {&#10;        payload: Readonly&lt;T&gt;;&#10;        timestamp: Date;&#10;        instanceId: string;&#10;    };&#10;    export type WorkflowStepEvent&lt;T&gt; = {&#10;        payload: Readonly&lt;T&gt;;&#10;        timestamp: Date;&#10;        type: string;&#10;    };&#10;    export abstract class WorkflowStep {&#10;        do&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;        do&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, config: WorkflowStepConfig, callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;        sleep: (name: string, duration: WorkflowSleepDuration) =&gt; Promise&lt;void&gt;;&#10;        sleepUntil: (name: string, timestamp: Date | number) =&gt; Promise&lt;void&gt;;&#10;        waitForEvent&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, options: {&#10;            type: string;&#10;            timeout?: WorkflowTimeoutDuration | number;&#10;        }): Promise&lt;WorkflowStepEvent&lt;T&gt;&gt;;&#10;    }&#10;    export abstract class WorkflowEntrypoint&lt;Env = unknown, T extends Rpc.Serializable&lt;T&gt; | unknown = unknown&gt; implements Rpc.WorkflowEntrypointBranded {&#10;        [Rpc.__WORKFLOW_ENTRYPOINT_BRAND]: never;&#10;        protected ctx: ExecutionContext;&#10;        protected env: Env;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        run(event: Readonly&lt;WorkflowEvent&lt;T&gt;&gt;, step: WorkflowStep): Promise&lt;unknown&gt;;&#10;    }&#10;    export function waitUntil(promise: Promise&lt;unknown&gt;): void;&#10;    export const env: Cloudflare.Env;&#10;}&#10;" />
              <option name="updatedContent" value="/* eslint-disable */&#10;// Generated by Wrangler by running `wrangler types` (hash: 869ac3b4ce0f52ba3b2e0bc70c49089e)&#10;// Runtime types generated with workerd@1.20250730.0 2025-08-02&#10;declare namespace Cloudflare {&#10;&#9;interface Env {&#10;&#9;&#9;JINJYA_STORE: KVNamespace;&#10;&#9;&#9;JINJYA_DB: D1Database;&#10;&#9;&#9;RATE_LIMIT: KVNamespace;&#10;&#9;}&#10;}&#10;&#10;interface Env extends Cloudflare.Env {}&#10;export {}&#10;// Begin runtime types&#10;/*! *****************************************************************************&#10;Copyright (c) Cloudflare. All rights reserved.&#10;Copyright (c) Microsoft Corporation. All rights reserved.&#10;&#10;Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use&#10;this file except in compliance with the License. You may obtain a copy of the&#10;License at http://www.apache.org/licenses/LICENSE-2.0&#10;THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY&#10;KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED&#10;WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,&#10;MERCHANTABLITY OR NON-INFRINGEMENT.&#10;See the Apache Version 2.0 License for specific language governing permissions&#10;and limitations under the License.&#10;***************************************************************************** */&#10;/* eslint-disable */&#10;// noinspection JSUnusedGlobalSymbols&#10;declare var onmessage: never;&#10;/**&#10; * An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)&#10; */&#10;declare class DOMException extends Error {&#10;    constructor(message?: string, name?: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/message) */&#10;    readonly message: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/name) */&#10;    readonly name: string;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/code)&#10;     */&#10;    readonly code: number;&#10;    static readonly INDEX_SIZE_ERR: number;&#10;    static readonly DOMSTRING_SIZE_ERR: number;&#10;    static readonly HIERARCHY_REQUEST_ERR: number;&#10;    static readonly WRONG_DOCUMENT_ERR: number;&#10;    static readonly INVALID_CHARACTER_ERR: number;&#10;    static readonly NO_DATA_ALLOWED_ERR: number;&#10;    static readonly NO_MODIFICATION_ALLOWED_ERR: number;&#10;    static readonly NOT_FOUND_ERR: number;&#10;    static readonly NOT_SUPPORTED_ERR: number;&#10;    static readonly INUSE_ATTRIBUTE_ERR: number;&#10;    static readonly INVALID_STATE_ERR: number;&#10;    static readonly SYNTAX_ERR: number;&#10;    static readonly INVALID_MODIFICATION_ERR: number;&#10;    static readonly NAMESPACE_ERR: number;&#10;    static readonly INVALID_ACCESS_ERR: number;&#10;    static readonly VALIDATION_ERR: number;&#10;    static readonly TYPE_MISMATCH_ERR: number;&#10;    static readonly SECURITY_ERR: number;&#10;    static readonly NETWORK_ERR: number;&#10;    static readonly ABORT_ERR: number;&#10;    static readonly URL_MISMATCH_ERR: number;&#10;    static readonly QUOTA_EXCEEDED_ERR: number;&#10;    static readonly TIMEOUT_ERR: number;&#10;    static readonly INVALID_NODE_TYPE_ERR: number;&#10;    static readonly DATA_CLONE_ERR: number;&#10;    get stack(): any;&#10;    set stack(value: any);&#10;}&#10;type WorkerGlobalScopeEventMap = {&#10;    fetch: FetchEvent;&#10;    scheduled: ScheduledEvent;&#10;    queue: QueueEvent;&#10;    unhandledrejection: PromiseRejectionEvent;&#10;    rejectionhandled: PromiseRejectionEvent;&#10;};&#10;declare abstract class WorkerGlobalScope extends EventTarget&lt;WorkerGlobalScopeEventMap&gt; {&#10;    EventTarget: typeof EventTarget;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */&#10;interface Console {&#10;    &quot;assert&quot;(condition?: boolean, ...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/clear_static) */&#10;    clear(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/count_static) */&#10;    count(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/countReset_static) */&#10;    countReset(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/debug_static) */&#10;    debug(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dir_static) */&#10;    dir(item?: any, options?: any): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dirxml_static) */&#10;    dirxml(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/error_static) */&#10;    error(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/group_static) */&#10;    group(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupCollapsed_static) */&#10;    groupCollapsed(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupEnd_static) */&#10;    groupEnd(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/info_static) */&#10;    info(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static) */&#10;    log(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/table_static) */&#10;    table(tabularData?: any, properties?: string[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/time_static) */&#10;    time(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeEnd_static) */&#10;    timeEnd(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeLog_static) */&#10;    timeLog(label?: string, ...data: any[]): void;&#10;    timeStamp(label?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/trace_static) */&#10;    trace(...data: any[]): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/warn_static) */&#10;    warn(...data: any[]): void;&#10;}&#10;declare const console: Console;&#10;type BufferSource = ArrayBufferView | ArrayBuffer;&#10;type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;&#10;declare namespace WebAssembly {&#10;    class CompileError extends Error {&#10;        constructor(message?: string);&#10;    }&#10;    class RuntimeError extends Error {&#10;        constructor(message?: string);&#10;    }&#10;    type ValueType = &quot;anyfunc&quot; | &quot;externref&quot; | &quot;f32&quot; | &quot;f64&quot; | &quot;i32&quot; | &quot;i64&quot; | &quot;v128&quot;;&#10;    interface GlobalDescriptor {&#10;        value: ValueType;&#10;        mutable?: boolean;&#10;    }&#10;    class Global {&#10;        constructor(descriptor: GlobalDescriptor, value?: any);&#10;        value: any;&#10;        valueOf(): any;&#10;    }&#10;    type ImportValue = ExportValue | number;&#10;    type ModuleImports = Record&lt;string, ImportValue&gt;;&#10;    type Imports = Record&lt;string, ModuleImports&gt;;&#10;    type ExportValue = Function | Global | Memory | Table;&#10;    type Exports = Record&lt;string, ExportValue&gt;;&#10;    class Instance {&#10;        constructor(module: Module, imports?: Imports);&#10;        readonly exports: Exports;&#10;    }&#10;    interface MemoryDescriptor {&#10;        initial: number;&#10;        maximum?: number;&#10;        shared?: boolean;&#10;    }&#10;    class Memory {&#10;        constructor(descriptor: MemoryDescriptor);&#10;        readonly buffer: ArrayBuffer;&#10;        grow(delta: number): number;&#10;    }&#10;    type ImportExportKind = &quot;function&quot; | &quot;global&quot; | &quot;memory&quot; | &quot;table&quot;;&#10;    interface ModuleExportDescriptor {&#10;        kind: ImportExportKind;&#10;        name: string;&#10;    }&#10;    interface ModuleImportDescriptor {&#10;        kind: ImportExportKind;&#10;        module: string;&#10;        name: string;&#10;    }&#10;    abstract class Module {&#10;        static customSections(module: Module, sectionName: string): ArrayBuffer[];&#10;        static exports(module: Module): ModuleExportDescriptor[];&#10;        static imports(module: Module): ModuleImportDescriptor[];&#10;    }&#10;    type TableKind = &quot;anyfunc&quot; | &quot;externref&quot;;&#10;    interface TableDescriptor {&#10;        element: TableKind;&#10;        initial: number;&#10;        maximum?: number;&#10;    }&#10;    class Table {&#10;        constructor(descriptor: TableDescriptor, value?: any);&#10;        readonly length: number;&#10;        get(index: number): any;&#10;        grow(delta: number, value?: any): number;&#10;        set(index: number, value?: any): void;&#10;    }&#10;    function instantiate(module: Module, imports?: Imports): Promise&lt;Instance&gt;;&#10;    function validate(bytes: BufferSource): boolean;&#10;}&#10;/**&#10; * This ServiceWorker API interface represents the global execution context of a service worker.&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope)&#10; */&#10;interface ServiceWorkerGlobalScope extends WorkerGlobalScope {&#10;    DOMException: typeof DOMException;&#10;    WorkerGlobalScope: typeof WorkerGlobalScope;&#10;    btoa(data: string): string;&#10;    atob(data: string): string;&#10;    setTimeout(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;    setTimeout&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;    clearTimeout(timeoutId: number | null): void;&#10;    setInterval(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;    setInterval&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;    clearInterval(timeoutId: number | null): void;&#10;    queueMicrotask(task: Function): void;&#10;    structuredClone&lt;T&gt;(value: T, options?: StructuredSerializeOptions): T;&#10;    reportError(error: any): void;&#10;    fetch(input: RequestInfo | URL, init?: RequestInit&lt;RequestInitCfProperties&gt;): Promise&lt;Response&gt;;&#10;    self: ServiceWorkerGlobalScope;&#10;    crypto: Crypto;&#10;    caches: CacheStorage;&#10;    scheduler: Scheduler;&#10;    performance: Performance;&#10;    Cloudflare: Cloudflare;&#10;    readonly origin: string;&#10;    Event: typeof Event;&#10;    ExtendableEvent: typeof ExtendableEvent;&#10;    CustomEvent: typeof CustomEvent;&#10;    PromiseRejectionEvent: typeof PromiseRejectionEvent;&#10;    FetchEvent: typeof FetchEvent;&#10;    TailEvent: typeof TailEvent;&#10;    TraceEvent: typeof TailEvent;&#10;    ScheduledEvent: typeof ScheduledEvent;&#10;    MessageEvent: typeof MessageEvent;&#10;    CloseEvent: typeof CloseEvent;&#10;    ReadableStreamDefaultReader: typeof ReadableStreamDefaultReader;&#10;    ReadableStreamBYOBReader: typeof ReadableStreamBYOBReader;&#10;    ReadableStream: typeof ReadableStream;&#10;    WritableStream: typeof WritableStream;&#10;    WritableStreamDefaultWriter: typeof WritableStreamDefaultWriter;&#10;    TransformStream: typeof TransformStream;&#10;    ByteLengthQueuingStrategy: typeof ByteLengthQueuingStrategy;&#10;    CountQueuingStrategy: typeof CountQueuingStrategy;&#10;    ErrorEvent: typeof ErrorEvent;&#10;    EventSource: typeof EventSource;&#10;    ReadableStreamBYOBRequest: typeof ReadableStreamBYOBRequest;&#10;    ReadableStreamDefaultController: typeof ReadableStreamDefaultController;&#10;    ReadableByteStreamController: typeof ReadableByteStreamController;&#10;    WritableStreamDefaultController: typeof WritableStreamDefaultController;&#10;    TransformStreamDefaultController: typeof TransformStreamDefaultController;&#10;    CompressionStream: typeof CompressionStream;&#10;    DecompressionStream: typeof DecompressionStream;&#10;    TextEncoderStream: typeof TextEncoderStream;&#10;    TextDecoderStream: typeof TextDecoderStream;&#10;    Headers: typeof Headers;&#10;    Body: typeof Body;&#10;    Request: typeof Request;&#10;    Response: typeof Response;&#10;    WebSocket: typeof WebSocket;&#10;    WebSocketPair: typeof WebSocketPair;&#10;    WebSocketRequestResponsePair: typeof WebSocketRequestResponsePair;&#10;    AbortController: typeof AbortController;&#10;    AbortSignal: typeof AbortSignal;&#10;    TextDecoder: typeof TextDecoder;&#10;    TextEncoder: typeof TextEncoder;&#10;    navigator: Navigator;&#10;    Navigator: typeof Navigator;&#10;    URL: typeof URL;&#10;    URLSearchParams: typeof URLSearchParams;&#10;    URLPattern: typeof URLPattern;&#10;    Blob: typeof Blob;&#10;    File: typeof File;&#10;    FormData: typeof FormData;&#10;    Crypto: typeof Crypto;&#10;    SubtleCrypto: typeof SubtleCrypto;&#10;    CryptoKey: typeof CryptoKey;&#10;    CacheStorage: typeof CacheStorage;&#10;    Cache: typeof Cache;&#10;    FixedLengthStream: typeof FixedLengthStream;&#10;    IdentityTransformStream: typeof IdentityTransformStream;&#10;    HTMLRewriter: typeof HTMLRewriter;&#10;}&#10;declare function addEventListener&lt;Type extends keyof WorkerGlobalScopeEventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;WorkerGlobalScopeEventMap[Type]&gt;, options?: EventTargetAddEventListenerOptions | boolean): void;&#10;declare function removeEventListener&lt;Type extends keyof WorkerGlobalScopeEventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;WorkerGlobalScopeEventMap[Type]&gt;, options?: EventTargetEventListenerOptions | boolean): void;&#10;/**&#10; * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)&#10; */&#10;declare function dispatchEvent(event: WorkerGlobalScopeEventMap[keyof WorkerGlobalScopeEventMap]): boolean;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/btoa) */&#10;declare function btoa(data: string): string;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/atob) */&#10;declare function atob(data: string): string;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */&#10;declare function setTimeout(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */&#10;declare function setTimeout&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearTimeout) */&#10;declare function clearTimeout(timeoutId: number | null): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */&#10;declare function setInterval(callback: (...args: any[]) =&gt; void, msDelay?: number): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */&#10;declare function setInterval&lt;Args extends any[]&gt;(callback: (...args: Args) =&gt; void, msDelay?: number, ...args: Args): number;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearInterval) */&#10;declare function clearInterval(timeoutId: number | null): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/queueMicrotask) */&#10;declare function queueMicrotask(task: Function): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/structuredClone) */&#10;declare function structuredClone&lt;T&gt;(value: T, options?: StructuredSerializeOptions): T;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/reportError) */&#10;declare function reportError(error: any): void;&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/fetch) */&#10;declare function fetch(input: RequestInfo | URL, init?: RequestInit&lt;RequestInitCfProperties&gt;): Promise&lt;Response&gt;;&#10;declare const self: ServiceWorkerGlobalScope;&#10;/**&#10;* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.&#10;* The Workers runtime implements the full surface of this API, but with some differences in&#10;* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)&#10;* compared to those implemented in most browsers.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)&#10;*/&#10;declare const crypto: Crypto;&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare const caches: CacheStorage;&#10;declare const scheduler: Scheduler;&#10;/**&#10;* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,&#10;* as well as timing of subrequests and other operations.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)&#10;*/&#10;declare const performance: Performance;&#10;declare const Cloudflare: Cloudflare;&#10;declare const origin: string;&#10;declare const navigator: Navigator;&#10;interface TestController {&#10;}&#10;interface ExecutionContext {&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;    passThroughOnException(): void;&#10;    props: any;&#10;}&#10;type ExportedHandlerFetchHandler&lt;Env = unknown, CfHostMetadata = unknown&gt; = (request: Request&lt;CfHostMetadata, IncomingRequestCfProperties&lt;CfHostMetadata&gt;&gt;, env: Env, ctx: ExecutionContext) =&gt; Response | Promise&lt;Response&gt;;&#10;type ExportedHandlerTailHandler&lt;Env = unknown&gt; = (events: TraceItem[], env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTraceHandler&lt;Env = unknown&gt; = (traces: TraceItem[], env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTailStreamHandler&lt;Env = unknown&gt; = (event: TailStream.TailEvent&lt;TailStream.Onset&gt;, env: Env, ctx: ExecutionContext) =&gt; TailStream.TailEventHandlerType | Promise&lt;TailStream.TailEventHandlerType&gt;;&#10;type ExportedHandlerScheduledHandler&lt;Env = unknown&gt; = (controller: ScheduledController, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerQueueHandler&lt;Env = unknown, Message = unknown&gt; = (batch: MessageBatch&lt;Message&gt;, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;type ExportedHandlerTestHandler&lt;Env = unknown&gt; = (controller: TestController, env: Env, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;;&#10;interface ExportedHandler&lt;Env = unknown, QueueHandlerMessage = unknown, CfHostMetadata = unknown&gt; {&#10;    fetch?: ExportedHandlerFetchHandler&lt;Env, CfHostMetadata&gt;;&#10;    tail?: ExportedHandlerTailHandler&lt;Env&gt;;&#10;    trace?: ExportedHandlerTraceHandler&lt;Env&gt;;&#10;    tailStream?: ExportedHandlerTailStreamHandler&lt;Env&gt;;&#10;    scheduled?: ExportedHandlerScheduledHandler&lt;Env&gt;;&#10;    test?: ExportedHandlerTestHandler&lt;Env&gt;;&#10;    email?: EmailExportedHandler&lt;Env&gt;;&#10;    queue?: ExportedHandlerQueueHandler&lt;Env, QueueHandlerMessage&gt;;&#10;}&#10;interface StructuredSerializeOptions {&#10;    transfer?: any[];&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */&#10;declare abstract class PromiseRejectionEvent extends Event {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise) */&#10;    readonly promise: Promise&lt;any&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason) */&#10;    readonly reason: any;&#10;}&#10;declare abstract class Navigator {&#10;    sendBeacon(url: string, body?: (ReadableStream | string | (ArrayBuffer | ArrayBufferView) | Blob | FormData | URLSearchParams | URLSearchParams)): boolean;&#10;    readonly userAgent: string;&#10;    readonly hardwareConcurrency: number;&#10;    readonly language: string;&#10;    readonly languages: string[];&#10;}&#10;/**&#10;* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,&#10;* as well as timing of subrequests and other operations.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)&#10;*/&#10;interface Performance {&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancetimeorigin) */&#10;    readonly timeOrigin: number;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancenow) */&#10;    now(): number;&#10;}&#10;interface AlarmInvocationInfo {&#10;    readonly isRetry: boolean;&#10;    readonly retryCount: number;&#10;}&#10;interface Cloudflare {&#10;    readonly compatibilityFlags: Record&lt;string, boolean&gt;;&#10;}&#10;interface DurableObject {&#10;    fetch(request: Request): Response | Promise&lt;Response&gt;;&#10;    alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise&lt;void&gt;;&#10;    webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise&lt;void&gt;;&#10;    webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise&lt;void&gt;;&#10;    webSocketError?(ws: WebSocket, error: unknown): void | Promise&lt;void&gt;;&#10;}&#10;type DurableObjectStub&lt;T extends Rpc.DurableObjectBranded | undefined = undefined&gt; = Fetcher&lt;T, &quot;alarm&quot; | &quot;webSocketMessage&quot; | &quot;webSocketClose&quot; | &quot;webSocketError&quot;&gt; &amp; {&#10;    readonly id: DurableObjectId;&#10;    readonly name?: string;&#10;};&#10;interface DurableObjectId {&#10;    toString(): string;&#10;    equals(other: DurableObjectId): boolean;&#10;    readonly name?: string;&#10;}&#10;interface DurableObjectNamespace&lt;T extends Rpc.DurableObjectBranded | undefined = undefined&gt; {&#10;    newUniqueId(options?: DurableObjectNamespaceNewUniqueIdOptions): DurableObjectId;&#10;    idFromName(name: string): DurableObjectId;&#10;    idFromString(id: string): DurableObjectId;&#10;    get(id: DurableObjectId, options?: DurableObjectNamespaceGetDurableObjectOptions): DurableObjectStub&lt;T&gt;;&#10;    jurisdiction(jurisdiction: DurableObjectJurisdiction): DurableObjectNamespace&lt;T&gt;;&#10;}&#10;type DurableObjectJurisdiction = &quot;eu&quot; | &quot;fedramp&quot; | &quot;fedramp-high&quot;;&#10;interface DurableObjectNamespaceNewUniqueIdOptions {&#10;    jurisdiction?: DurableObjectJurisdiction;&#10;}&#10;type DurableObjectLocationHint = &quot;wnam&quot; | &quot;enam&quot; | &quot;sam&quot; | &quot;weur&quot; | &quot;eeur&quot; | &quot;apac&quot; | &quot;oc&quot; | &quot;afr&quot; | &quot;me&quot;;&#10;interface DurableObjectNamespaceGetDurableObjectOptions {&#10;    locationHint?: DurableObjectLocationHint;&#10;}&#10;interface DurableObjectState {&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;    readonly id: DurableObjectId;&#10;    readonly storage: DurableObjectStorage;&#10;    container?: Container;&#10;    blockConcurrencyWhile&lt;T&gt;(callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;    acceptWebSocket(ws: WebSocket, tags?: string[]): void;&#10;    getWebSockets(tag?: string): WebSocket[];&#10;    setWebSocketAutoResponse(maybeReqResp?: WebSocketRequestResponsePair): void;&#10;    getWebSocketAutoResponse(): WebSocketRequestResponsePair | null;&#10;    getWebSocketAutoResponseTimestamp(ws: WebSocket): Date | null;&#10;    setHibernatableWebSocketEventTimeout(timeoutMs?: number): void;&#10;    getHibernatableWebSocketEventTimeout(): number | null;&#10;    getTags(ws: WebSocket): string[];&#10;    abort(reason?: string): void;&#10;}&#10;interface DurableObjectTransaction {&#10;    get&lt;T = unknown&gt;(key: string, options?: DurableObjectGetOptions): Promise&lt;T | undefined&gt;;&#10;    get&lt;T = unknown&gt;(keys: string[], options?: DurableObjectGetOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    list&lt;T = unknown&gt;(options?: DurableObjectListOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    put&lt;T&gt;(key: string, value: T, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    put&lt;T&gt;(entries: Record&lt;string, T&gt;, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    delete(key: string, options?: DurableObjectPutOptions): Promise&lt;boolean&gt;;&#10;    delete(keys: string[], options?: DurableObjectPutOptions): Promise&lt;number&gt;;&#10;    rollback(): void;&#10;    getAlarm(options?: DurableObjectGetAlarmOptions): Promise&lt;number | null&gt;;&#10;    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;}&#10;interface DurableObjectStorage {&#10;    get&lt;T = unknown&gt;(key: string, options?: DurableObjectGetOptions): Promise&lt;T | undefined&gt;;&#10;    get&lt;T = unknown&gt;(keys: string[], options?: DurableObjectGetOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    list&lt;T = unknown&gt;(options?: DurableObjectListOptions): Promise&lt;Map&lt;string, T&gt;&gt;;&#10;    put&lt;T&gt;(key: string, value: T, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    put&lt;T&gt;(entries: Record&lt;string, T&gt;, options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    delete(key: string, options?: DurableObjectPutOptions): Promise&lt;boolean&gt;;&#10;    delete(keys: string[], options?: DurableObjectPutOptions): Promise&lt;number&gt;;&#10;    deleteAll(options?: DurableObjectPutOptions): Promise&lt;void&gt;;&#10;    transaction&lt;T&gt;(closure: (txn: DurableObjectTransaction) =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;    getAlarm(options?: DurableObjectGetAlarmOptions): Promise&lt;number | null&gt;;&#10;    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise&lt;void&gt;;&#10;    sync(): Promise&lt;void&gt;;&#10;    sql: SqlStorage;&#10;    transactionSync&lt;T&gt;(closure: () =&gt; T): T;&#10;    getCurrentBookmark(): Promise&lt;string&gt;;&#10;    getBookmarkForTime(timestamp: number | Date): Promise&lt;string&gt;;&#10;    onNextSessionRestoreBookmark(bookmark: string): Promise&lt;string&gt;;&#10;}&#10;interface DurableObjectListOptions {&#10;    start?: string;&#10;    startAfter?: string;&#10;    end?: string;&#10;    prefix?: string;&#10;    reverse?: boolean;&#10;    limit?: number;&#10;    allowConcurrency?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectGetOptions {&#10;    allowConcurrency?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectGetAlarmOptions {&#10;    allowConcurrency?: boolean;&#10;}&#10;interface DurableObjectPutOptions {&#10;    allowConcurrency?: boolean;&#10;    allowUnconfirmed?: boolean;&#10;    noCache?: boolean;&#10;}&#10;interface DurableObjectSetAlarmOptions {&#10;    allowConcurrency?: boolean;&#10;    allowUnconfirmed?: boolean;&#10;}&#10;declare class WebSocketRequestResponsePair {&#10;    constructor(request: string, response: string);&#10;    get request(): string;&#10;    get response(): string;&#10;}&#10;interface AnalyticsEngineDataset {&#10;    writeDataPoint(event?: AnalyticsEngineDataPoint): void;&#10;}&#10;interface AnalyticsEngineDataPoint {&#10;    indexes?: ((ArrayBuffer | string) | null)[];&#10;    doubles?: number[];&#10;    blobs?: ((ArrayBuffer | string) | null)[];&#10;}&#10;/**&#10; * An event which takes place in the DOM.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)&#10; */&#10;declare class Event {&#10;    constructor(type: string, init?: EventInit);&#10;    /**&#10;     * Returns the type of event, e.g. &quot;click&quot;, &quot;hashchange&quot;, or &quot;submit&quot;.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/type)&#10;     */&#10;    get type(): string;&#10;    /**&#10;     * Returns the event's phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/eventPhase)&#10;     */&#10;    get eventPhase(): number;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composed)&#10;     */&#10;    get composed(): boolean;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. True if event goes through its target's ancestors in reverse tree order, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/bubbles)&#10;     */&#10;    get bubbles(): boolean;&#10;    /**&#10;     * Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelable)&#10;     */&#10;    get cancelable(): boolean;&#10;    /**&#10;     * Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/defaultPrevented)&#10;     */&#10;    get defaultPrevented(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/returnValue)&#10;     */&#10;    get returnValue(): boolean;&#10;    /**&#10;     * Returns the object whose event listener's callback is currently being invoked.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/currentTarget)&#10;     */&#10;    get currentTarget(): EventTarget | undefined;&#10;    /**&#10;     * Returns the object to which event is dispatched (its target).&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/target)&#10;     */&#10;    get target(): EventTarget | undefined;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/srcElement)&#10;     */&#10;    get srcElement(): EventTarget | undefined;&#10;    /**&#10;     * Returns the event's timestamp as the number of milliseconds measured relative to the time origin.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/timeStamp)&#10;     */&#10;    get timeStamp(): number;&#10;    /**&#10;     * Returns true if event was dispatched by the user agent, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/isTrusted)&#10;     */&#10;    get isTrusted(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)&#10;     */&#10;    get cancelBubble(): boolean;&#10;    /**&#10;     * @deprecated&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)&#10;     */&#10;    set cancelBubble(value: boolean);&#10;    /**&#10;     * Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopImmediatePropagation)&#10;     */&#10;    stopImmediatePropagation(): void;&#10;    /**&#10;     * If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/preventDefault)&#10;     */&#10;    preventDefault(): void;&#10;    /**&#10;     * When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation)&#10;     */&#10;    stopPropagation(): void;&#10;    /**&#10;     * Returns the invocation target objects of event's path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root's mode is &quot;closed&quot; that are not reachable from event's currentTarget.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composedPath)&#10;     */&#10;    composedPath(): EventTarget[];&#10;    static readonly NONE: number;&#10;    static readonly CAPTURING_PHASE: number;&#10;    static readonly AT_TARGET: number;&#10;    static readonly BUBBLING_PHASE: number;&#10;}&#10;interface EventInit {&#10;    bubbles?: boolean;&#10;    cancelable?: boolean;&#10;    composed?: boolean;&#10;}&#10;type EventListener&lt;EventType extends Event = Event&gt; = (event: EventType) =&gt; void;&#10;interface EventListenerObject&lt;EventType extends Event = Event&gt; {&#10;    handleEvent(event: EventType): void;&#10;}&#10;type EventListenerOrEventListenerObject&lt;EventType extends Event = Event&gt; = EventListener&lt;EventType&gt; | EventListenerObject&lt;EventType&gt;;&#10;/**&#10; * EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)&#10; */&#10;declare class EventTarget&lt;EventMap extends Record&lt;string, Event&gt; = Record&lt;string, Event&gt;&gt; {&#10;    constructor();&#10;    /**&#10;     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.&#10;     *&#10;     * The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.&#10;     *&#10;     * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.&#10;     *&#10;     * When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.&#10;     *&#10;     * When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.&#10;     *&#10;     * If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.&#10;     *&#10;     * The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener)&#10;     */&#10;    addEventListener&lt;Type extends keyof EventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;EventMap[Type]&gt;, options?: EventTargetAddEventListenerOptions | boolean): void;&#10;    /**&#10;     * Removes the event listener in target's event listener list with the same type, callback, and options.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/removeEventListener)&#10;     */&#10;    removeEventListener&lt;Type extends keyof EventMap&gt;(type: Type, handler: EventListenerOrEventListenerObject&lt;EventMap[Type]&gt;, options?: EventTargetEventListenerOptions | boolean): void;&#10;    /**&#10;     * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)&#10;     */&#10;    dispatchEvent(event: EventMap[keyof EventMap]): boolean;&#10;}&#10;interface EventTargetEventListenerOptions {&#10;    capture?: boolean;&#10;}&#10;interface EventTargetAddEventListenerOptions {&#10;    capture?: boolean;&#10;    passive?: boolean;&#10;    once?: boolean;&#10;    signal?: AbortSignal;&#10;}&#10;interface EventTargetHandlerObject {&#10;    handleEvent: (event: Event) =&gt; any | undefined;&#10;}&#10;/**&#10; * A controller object that allows you to abort one or more DOM requests as and when desired.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)&#10; */&#10;declare class AbortController {&#10;    constructor();&#10;    /**&#10;     * Returns the AbortSignal object associated with this object.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/signal)&#10;     */&#10;    get signal(): AbortSignal;&#10;    /**&#10;     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/abort)&#10;     */&#10;    abort(reason?: any): void;&#10;}&#10;/**&#10; * A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)&#10; */&#10;declare abstract class AbortSignal extends EventTarget {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_static) */&#10;    static abort(reason?: any): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/timeout_static) */&#10;    static timeout(delay: number): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/any_static) */&#10;    static any(signals: AbortSignal[]): AbortSignal;&#10;    /**&#10;     * Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/aborted)&#10;     */&#10;    get aborted(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/reason) */&#10;    get reason(): any;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */&#10;    get onabort(): any | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */&#10;    set onabort(value: any | null);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/throwIfAborted) */&#10;    throwIfAborted(): void;&#10;}&#10;interface Scheduler {&#10;    wait(delay: number, maybeOptions?: SchedulerWaitOptions): Promise&lt;void&gt;;&#10;}&#10;interface SchedulerWaitOptions {&#10;    signal?: AbortSignal;&#10;}&#10;/**&#10; * Extends the lifetime of the install and activate events dispatched on the global scope as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched until it upgrades database schemas and deletes the outdated cache entries.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent)&#10; */&#10;declare abstract class ExtendableEvent extends Event {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil) */&#10;    waitUntil(promise: Promise&lt;any&gt;): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */&#10;declare class CustomEvent&lt;T = any&gt; extends Event {&#10;    constructor(type: string, init?: CustomEventCustomEventInit);&#10;    /**&#10;     * Returns any custom data event was created with. Typically used for synthetic events.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent/detail)&#10;     */&#10;    get detail(): T;&#10;}&#10;interface CustomEventCustomEventInit {&#10;    bubbles?: boolean;&#10;    cancelable?: boolean;&#10;    composed?: boolean;&#10;    detail?: any;&#10;}&#10;/**&#10; * A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)&#10; */&#10;declare class Blob {&#10;    constructor(type?: ((ArrayBuffer | ArrayBufferView) | string | Blob)[], options?: BlobOptions);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */&#10;    get size(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */&#10;    get type(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */&#10;    slice(start?: number, end?: number, type?: string): Blob;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/arrayBuffer) */&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/bytes) */&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */&#10;    text(): Promise&lt;string&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/stream) */&#10;    stream(): ReadableStream;&#10;}&#10;interface BlobOptions {&#10;    type?: string;&#10;}&#10;/**&#10; * Provides information about files and allows JavaScript in a web page to access their content.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)&#10; */&#10;declare class File extends Blob {&#10;    constructor(bits: ((ArrayBuffer | ArrayBufferView) | string | Blob)[] | undefined, name: string, options?: FileOptions);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */&#10;    get name(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */&#10;    get lastModified(): number;&#10;}&#10;interface FileOptions {&#10;    type?: string;&#10;    lastModified?: number;&#10;}&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare abstract class CacheStorage {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage/open) */&#10;    open(cacheName: string): Promise&lt;Cache&gt;;&#10;    readonly default: Cache;&#10;}&#10;/**&#10;* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)&#10;*/&#10;declare abstract class Cache {&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#delete) */&#10;    delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;boolean&gt;;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#match) */&#10;    match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise&lt;Response | undefined&gt;;&#10;    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#put) */&#10;    put(request: RequestInfo | URL, response: Response): Promise&lt;void&gt;;&#10;}&#10;interface CacheQueryOptions {&#10;    ignoreMethod?: boolean;&#10;}&#10;/**&#10;* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.&#10;* The Workers runtime implements the full surface of this API, but with some differences in&#10;* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)&#10;* compared to those implemented in most browsers.&#10;*&#10;* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)&#10;*/&#10;declare abstract class Crypto {&#10;    /**&#10;     * Available only in secure contexts.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/subtle)&#10;     */&#10;    get subtle(): SubtleCrypto;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/getRandomValues) */&#10;    getRandomValues&lt;T extends Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | BigInt64Array | BigUint64Array&gt;(buffer: T): T;&#10;    /**&#10;     * Available only in secure contexts.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/randomUUID)&#10;     */&#10;    randomUUID(): string;&#10;    DigestStream: typeof DigestStream;&#10;}&#10;/**&#10; * This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)&#10; */&#10;declare abstract class SubtleCrypto {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/encrypt) */&#10;    encrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, plainText: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/decrypt) */&#10;    decrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, cipherText: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/sign) */&#10;    sign(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, data: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/verify) */&#10;    verify(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, signature: ArrayBuffer | ArrayBufferView, data: ArrayBuffer | ArrayBufferView): Promise&lt;boolean&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/digest) */&#10;    digest(algorithm: string | SubtleCryptoHashAlgorithm, data: ArrayBuffer | ArrayBufferView): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey) */&#10;    generateKey(algorithm: string | SubtleCryptoGenerateKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey | CryptoKeyPair&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey) */&#10;    deriveKey(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, derivedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveBits) */&#10;    deriveBits(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, length?: number | null): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey) */&#10;    importKey(format: string, keyData: (ArrayBuffer | ArrayBufferView) | JsonWebKey, algorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/exportKey) */&#10;    exportKey(format: string, key: CryptoKey): Promise&lt;ArrayBuffer | JsonWebKey&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/wrapKey) */&#10;    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: string | SubtleCryptoEncryptAlgorithm): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey) */&#10;    unwrapKey(format: string, wrappedKey: ArrayBuffer | ArrayBufferView, unwrappingKey: CryptoKey, unwrapAlgorithm: string | SubtleCryptoEncryptAlgorithm, unwrappedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise&lt;CryptoKey&gt;;&#10;    timingSafeEqual(a: ArrayBuffer | ArrayBufferView, b: ArrayBuffer | ArrayBufferView): boolean;&#10;}&#10;/**&#10; * The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.&#10; * Available only in secure contexts.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)&#10; */&#10;declare abstract class CryptoKey {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/type) */&#10;    readonly type: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/extractable) */&#10;    readonly extractable: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/algorithm) */&#10;    readonly algorithm: CryptoKeyKeyAlgorithm | CryptoKeyAesKeyAlgorithm | CryptoKeyHmacKeyAlgorithm | CryptoKeyRsaKeyAlgorithm | CryptoKeyEllipticKeyAlgorithm | CryptoKeyArbitraryKeyAlgorithm;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/usages) */&#10;    readonly usages: string[];&#10;}&#10;interface CryptoKeyPair {&#10;    publicKey: CryptoKey;&#10;    privateKey: CryptoKey;&#10;}&#10;interface JsonWebKey {&#10;    kty: string;&#10;    use?: string;&#10;    key_ops?: string[];&#10;    alg?: string;&#10;    ext?: boolean;&#10;    crv?: string;&#10;    x?: string;&#10;    y?: string;&#10;    d?: string;&#10;    n?: string;&#10;    e?: string;&#10;    p?: string;&#10;    q?: string;&#10;    dp?: string;&#10;    dq?: string;&#10;    qi?: string;&#10;    oth?: RsaOtherPrimesInfo[];&#10;    k?: string;&#10;}&#10;interface RsaOtherPrimesInfo {&#10;    r?: string;&#10;    d?: string;&#10;    t?: string;&#10;}&#10;interface SubtleCryptoDeriveKeyAlgorithm {&#10;    name: string;&#10;    salt?: (ArrayBuffer | ArrayBufferView);&#10;    iterations?: number;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    $public?: CryptoKey;&#10;    info?: (ArrayBuffer | ArrayBufferView);&#10;}&#10;interface SubtleCryptoEncryptAlgorithm {&#10;    name: string;&#10;    iv?: (ArrayBuffer | ArrayBufferView);&#10;    additionalData?: (ArrayBuffer | ArrayBufferView);&#10;    tagLength?: number;&#10;    counter?: (ArrayBuffer | ArrayBufferView);&#10;    length?: number;&#10;    label?: (ArrayBuffer | ArrayBufferView);&#10;}&#10;interface SubtleCryptoGenerateKeyAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    modulusLength?: number;&#10;    publicExponent?: (ArrayBuffer | ArrayBufferView);&#10;    length?: number;&#10;    namedCurve?: string;&#10;}&#10;interface SubtleCryptoHashAlgorithm {&#10;    name: string;&#10;}&#10;interface SubtleCryptoImportKeyAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    length?: number;&#10;    namedCurve?: string;&#10;    compressed?: boolean;&#10;}&#10;interface SubtleCryptoSignAlgorithm {&#10;    name: string;&#10;    hash?: (string | SubtleCryptoHashAlgorithm);&#10;    dataLength?: number;&#10;    saltLength?: number;&#10;}&#10;interface CryptoKeyKeyAlgorithm {&#10;    name: string;&#10;}&#10;interface CryptoKeyAesKeyAlgorithm {&#10;    name: string;&#10;    length: number;&#10;}&#10;interface CryptoKeyHmacKeyAlgorithm {&#10;    name: string;&#10;    hash: CryptoKeyKeyAlgorithm;&#10;    length: number;&#10;}&#10;interface CryptoKeyRsaKeyAlgorithm {&#10;    name: string;&#10;    modulusLength: number;&#10;    publicExponent: ArrayBuffer | ArrayBufferView;&#10;    hash?: CryptoKeyKeyAlgorithm;&#10;}&#10;interface CryptoKeyEllipticKeyAlgorithm {&#10;    name: string;&#10;    namedCurve: string;&#10;}&#10;interface CryptoKeyArbitraryKeyAlgorithm {&#10;    name: string;&#10;    hash?: CryptoKeyKeyAlgorithm;&#10;    namedCurve?: string;&#10;    length?: number;&#10;}&#10;declare class DigestStream extends WritableStream&lt;ArrayBuffer | ArrayBufferView&gt; {&#10;    constructor(algorithm: string | SubtleCryptoHashAlgorithm);&#10;    readonly digest: Promise&lt;ArrayBuffer&gt;;&#10;    get bytesWritten(): number | bigint;&#10;}&#10;/**&#10; * A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)&#10; */&#10;declare class TextDecoder {&#10;    constructor(label?: string, options?: TextDecoderConstructorOptions);&#10;    /**&#10;     * Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented input. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.&#10;     *&#10;     * ```&#10;     * var string = &quot;&quot;, decoder = new TextDecoder(encoding), buffer;&#10;     * while(buffer = next_chunk()) {&#10;     *   string += decoder.decode(buffer, {stream:true});&#10;     * }&#10;     * string += decoder.decode(); // end-of-queue&#10;     * ```&#10;     *&#10;     * If the error mode is &quot;fatal&quot; and encoding's decoder returns error, throws a TypeError.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder/decode)&#10;     */&#10;    decode(input?: (ArrayBuffer | ArrayBufferView), options?: TextDecoderDecodeOptions): string;&#10;    get encoding(): string;&#10;    get fatal(): boolean;&#10;    get ignoreBOM(): boolean;&#10;}&#10;/**&#10; * TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)&#10; */&#10;declare class TextEncoder {&#10;    constructor();&#10;    /**&#10;     * Returns the result of running UTF-8's encoder.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encode)&#10;     */&#10;    encode(input?: string): Uint8Array;&#10;    /**&#10;     * Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encodeInto)&#10;     */&#10;    encodeInto(input: string, buffer: ArrayBuffer | ArrayBufferView): TextEncoderEncodeIntoResult;&#10;    get encoding(): string;&#10;}&#10;interface TextDecoderConstructorOptions {&#10;    fatal: boolean;&#10;    ignoreBOM: boolean;&#10;}&#10;interface TextDecoderDecodeOptions {&#10;    stream: boolean;&#10;}&#10;interface TextEncoderEncodeIntoResult {&#10;    read: number;&#10;    written: number;&#10;}&#10;/**&#10; * Events providing information related to errors in scripts or in files.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)&#10; */&#10;declare class ErrorEvent extends Event {&#10;    constructor(type: string, init?: ErrorEventErrorEventInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/filename) */&#10;    get filename(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/message) */&#10;    get message(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/lineno) */&#10;    get lineno(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/colno) */&#10;    get colno(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/error) */&#10;    get error(): any;&#10;}&#10;interface ErrorEventErrorEventInit {&#10;    message?: string;&#10;    filename?: string;&#10;    lineno?: number;&#10;    colno?: number;&#10;    error?: any;&#10;}&#10;/**&#10; * A message received by a target object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)&#10; */&#10;declare class MessageEvent extends Event {&#10;    constructor(type: string, initializer: MessageEventInit);&#10;    /**&#10;     * Returns the data of the message.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/data)&#10;     */&#10;    readonly data: any;&#10;    /**&#10;     * Returns the origin of the message, for server-sent events and cross-document messaging.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/origin)&#10;     */&#10;    readonly origin: string | null;&#10;    /**&#10;     * Returns the last event ID string, for server-sent events.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/lastEventId)&#10;     */&#10;    readonly lastEventId: string;&#10;    /**&#10;     * Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/source)&#10;     */&#10;    readonly source: MessagePort | null;&#10;    /**&#10;     * Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/ports)&#10;     */&#10;    readonly ports: MessagePort[];&#10;}&#10;interface MessageEventInit {&#10;    data: ArrayBuffer | string;&#10;}&#10;/**&#10; * Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to &quot;multipart/form-data&quot;.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)&#10; */&#10;declare class FormData {&#10;    constructor();&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */&#10;    append(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */&#10;    append(name: string, value: Blob, filename?: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/delete) */&#10;    delete(name: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/get) */&#10;    get(name: string): (File | string) | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/getAll) */&#10;    getAll(name: string): (File | string)[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/has) */&#10;    has(name: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */&#10;    set(name: string, value: Blob, filename?: string): void;&#10;    /* Returns an array of key, value pairs for every entry in the list. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: File | string&#10;    ]&gt;;&#10;    /* Returns a list of keys in the list. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns a list of values in the list. */&#10;    values(): IterableIterator&lt;(File | string)&gt;;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: File | string, key: string, parent: FormData) =&gt; void, thisArg?: This): void;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: File | string&#10;    ]&gt;;&#10;}&#10;interface ContentOptions {&#10;    html?: boolean;&#10;}&#10;declare class HTMLRewriter {&#10;    constructor();&#10;    on(selector: string, handlers: HTMLRewriterElementContentHandlers): HTMLRewriter;&#10;    onDocument(handlers: HTMLRewriterDocumentContentHandlers): HTMLRewriter;&#10;    transform(response: Response): Response;&#10;}&#10;interface HTMLRewriterElementContentHandlers {&#10;    element?(element: Element): void | Promise&lt;void&gt;;&#10;    comments?(comment: Comment): void | Promise&lt;void&gt;;&#10;    text?(element: Text): void | Promise&lt;void&gt;;&#10;}&#10;interface HTMLRewriterDocumentContentHandlers {&#10;    doctype?(doctype: Doctype): void | Promise&lt;void&gt;;&#10;    comments?(comment: Comment): void | Promise&lt;void&gt;;&#10;    text?(text: Text): void | Promise&lt;void&gt;;&#10;    end?(end: DocumentEnd): void | Promise&lt;void&gt;;&#10;}&#10;interface Doctype {&#10;    readonly name: string | null;&#10;    readonly publicId: string | null;&#10;    readonly systemId: string | null;&#10;}&#10;interface Element {&#10;    tagName: string;&#10;    readonly attributes: IterableIterator&lt;string[]&gt;;&#10;    readonly removed: boolean;&#10;    readonly namespaceURI: string;&#10;    getAttribute(name: string): string | null;&#10;    hasAttribute(name: string): boolean;&#10;    setAttribute(name: string, value: string): Element;&#10;    removeAttribute(name: string): Element;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    prepend(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    append(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    replace(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    remove(): Element;&#10;    removeAndKeepContent(): Element;&#10;    setInnerContent(content: string | ReadableStream | Response, options?: ContentOptions): Element;&#10;    onEndTag(handler: (tag: EndTag) =&gt; void | Promise&lt;void&gt;): void;&#10;}&#10;interface EndTag {&#10;    name: string;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;&#10;    remove(): EndTag;&#10;}&#10;interface Comment {&#10;    text: string;&#10;    readonly removed: boolean;&#10;    before(content: string, options?: ContentOptions): Comment;&#10;    after(content: string, options?: ContentOptions): Comment;&#10;    replace(content: string, options?: ContentOptions): Comment;&#10;    remove(): Comment;&#10;}&#10;interface Text {&#10;    readonly text: string;&#10;    readonly lastInTextNode: boolean;&#10;    readonly removed: boolean;&#10;    before(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    after(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    replace(content: string | ReadableStream | Response, options?: ContentOptions): Text;&#10;    remove(): Text;&#10;}&#10;interface DocumentEnd {&#10;    append(content: string, options?: ContentOptions): DocumentEnd;&#10;}&#10;/**&#10; * This is the event type for fetch events dispatched on the service worker global scope. It contains information about the fetch, including the request and how the receiver will treat the response. It provides the event.respondWith() method, which allows us to provide a response to this fetch.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent)&#10; */&#10;declare abstract class FetchEvent extends ExtendableEvent {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/request) */&#10;    readonly request: Request;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/respondWith) */&#10;    respondWith(promise: Response | Promise&lt;Response&gt;): void;&#10;    passThroughOnException(): void;&#10;}&#10;type HeadersInit = Headers | Iterable&lt;Iterable&lt;string&gt;&gt; | Record&lt;string, string&gt;;&#10;/**&#10; * This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)&#10; */&#10;declare class Headers {&#10;    constructor(init?: HeadersInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/get) */&#10;    get(name: string): string | null;&#10;    getAll(name: string): string[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/getSetCookie) */&#10;    getSetCookie(): string[];&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/has) */&#10;    has(name: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/set) */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/append) */&#10;    append(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/delete) */&#10;    delete(name: string): void;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: string, key: string, parent: Headers) =&gt; void, thisArg?: This): void;&#10;    /* Returns an iterator allowing to go through all key/value pairs contained in this object. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;    /* Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */&#10;    values(): IterableIterator&lt;string&gt;;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;}&#10;type BodyInit = ReadableStream&lt;Uint8Array&gt; | string | ArrayBuffer | ArrayBufferView | Blob | URLSearchParams | FormData;&#10;declare abstract class Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body) */&#10;    get body(): ReadableStream | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */&#10;    get bodyUsed(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes) */&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/text) */&#10;    text(): Promise&lt;string&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/json) */&#10;    json&lt;T&gt;(): Promise&lt;T&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/formData) */&#10;    formData(): Promise&lt;FormData&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */&#10;    blob(): Promise&lt;Blob&gt;;&#10;}&#10;/**&#10; * This Fetch API interface represents the response to a request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)&#10; */&#10;declare var Response: {&#10;    prototype: Response;&#10;    new (body?: BodyInit | null, init?: ResponseInit): Response;&#10;    error(): Response;&#10;    redirect(url: string, status?: number): Response;&#10;    json(any: any, maybeInit?: (ResponseInit | Response)): Response;&#10;};&#10;/**&#10; * This Fetch API interface represents the response to a request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)&#10; */&#10;interface Response extends Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/clone) */&#10;    clone(): Response;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/status) */&#10;    status: number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/statusText) */&#10;    statusText: string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/headers) */&#10;    headers: Headers;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/ok) */&#10;    ok: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/redirected) */&#10;    redirected: boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/url) */&#10;    url: string;&#10;    webSocket: WebSocket | null;&#10;    cf: any | undefined;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/type) */&#10;    type: &quot;default&quot; | &quot;error&quot;;&#10;}&#10;interface ResponseInit {&#10;    status?: number;&#10;    statusText?: string;&#10;    headers?: HeadersInit;&#10;    cf?: any;&#10;    webSocket?: (WebSocket | null);&#10;    encodeBody?: &quot;automatic&quot; | &quot;manual&quot;;&#10;}&#10;type RequestInfo&lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt; = Request&lt;CfHostMetadata, Cf&gt; | string;&#10;/**&#10; * This Fetch API interface represents a resource request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)&#10; */&#10;declare var Request: {&#10;    prototype: Request;&#10;    new &lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt;(input: RequestInfo&lt;CfProperties&gt; | URL, init?: RequestInit&lt;Cf&gt;): Request&lt;CfHostMetadata, Cf&gt;;&#10;};&#10;/**&#10; * This Fetch API interface represents a resource request.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)&#10; */&#10;interface Request&lt;CfHostMetadata = unknown, Cf = CfProperties&lt;CfHostMetadata&gt;&gt; extends Body {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/clone) */&#10;    clone(): Request&lt;CfHostMetadata, Cf&gt;;&#10;    /**&#10;     * Returns request's HTTP method, which is &quot;GET&quot; by default.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/method)&#10;     */&#10;    method: string;&#10;    /**&#10;     * Returns the URL of request as a string.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/url)&#10;     */&#10;    url: string;&#10;    /**&#10;     * Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the &quot;Host&quot; header.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/headers)&#10;     */&#10;    headers: Headers;&#10;    /**&#10;     * Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/redirect)&#10;     */&#10;    redirect: string;&#10;    fetcher: Fetcher | null;&#10;    /**&#10;     * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/signal)&#10;     */&#10;    signal: AbortSignal;&#10;    cf: Cf | undefined;&#10;    /**&#10;     * Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/integrity)&#10;     */&#10;    integrity: string;&#10;    /**&#10;     * Returns a boolean indicating whether or not request can outlive the global in which it was created.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/keepalive)&#10;     */&#10;    keepalive: boolean;&#10;    /**&#10;     * Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/cache)&#10;     */&#10;    cache?: &quot;no-store&quot;;&#10;}&#10;interface RequestInit&lt;Cf = CfProperties&gt; {&#10;    /* A string to set request's method. */&#10;    method?: string;&#10;    /* A Headers object, an object literal, or an array of two-item arrays to set request's headers. */&#10;    headers?: HeadersInit;&#10;    /* A BodyInit object or null to set request's body. */&#10;    body?: BodyInit | null;&#10;    /* A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */&#10;    redirect?: string;&#10;    fetcher?: (Fetcher | null);&#10;    cf?: Cf;&#10;    /* A string indicating how the request will interact with the browser's cache to set request's cache. */&#10;    cache?: &quot;no-store&quot;;&#10;    /* A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */&#10;    integrity?: string;&#10;    /* An AbortSignal to set request's signal. */&#10;    signal?: (AbortSignal | null);&#10;    encodeResponseBody?: &quot;automatic&quot; | &quot;manual&quot;;&#10;}&#10;type Service&lt;T extends (new (...args: any[]) =&gt; Rpc.WorkerEntrypointBranded) | Rpc.WorkerEntrypointBranded | ExportedHandler&lt;any, any, any&gt; | undefined = undefined&gt; = T extends new (...args: any[]) =&gt; Rpc.WorkerEntrypointBranded ? Fetcher&lt;InstanceType&lt;T&gt;&gt; : T extends Rpc.WorkerEntrypointBranded ? Fetcher&lt;T&gt; : T extends Exclude&lt;Rpc.EntrypointBranded, Rpc.WorkerEntrypointBranded&gt; ? never : Fetcher&lt;undefined&gt;;&#10;type Fetcher&lt;T extends Rpc.EntrypointBranded | undefined = undefined, Reserved extends string = never&gt; = (T extends Rpc.EntrypointBranded ? Rpc.Provider&lt;T, Reserved | &quot;fetch&quot; | &quot;connect&quot;&gt; : unknown) &amp; {&#10;    fetch(input: RequestInfo | URL, init?: RequestInit): Promise&lt;Response&gt;;&#10;    connect(address: SocketAddress | string, options?: SocketOptions): Socket;&#10;};&#10;interface KVNamespaceListKey&lt;Metadata, Key extends string = string&gt; {&#10;    name: Key;&#10;    expiration?: number;&#10;    metadata?: Metadata;&#10;}&#10;type KVNamespaceListResult&lt;Metadata, Key extends string = string&gt; = {&#10;    list_complete: false;&#10;    keys: KVNamespaceListKey&lt;Metadata, Key&gt;[];&#10;    cursor: string;&#10;    cacheStatus: string | null;&#10;} | {&#10;    list_complete: true;&#10;    keys: KVNamespaceListKey&lt;Metadata, Key&gt;[];&#10;    cacheStatus: string | null;&#10;};&#10;interface KVNamespace&lt;Key extends string = string&gt; {&#10;    get(key: Key, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;string | null&gt;;&#10;    get(key: Key, type: &quot;text&quot;): Promise&lt;string | null&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Key, type: &quot;json&quot;): Promise&lt;ExpectedValue | null&gt;;&#10;    get(key: Key, type: &quot;arrayBuffer&quot;): Promise&lt;ArrayBuffer | null&gt;;&#10;    get(key: Key, type: &quot;stream&quot;): Promise&lt;ReadableStream | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;string | null&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Key, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;ExpectedValue | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;arrayBuffer&quot;&gt;): Promise&lt;ArrayBuffer | null&gt;;&#10;    get(key: Key, options?: KVNamespaceGetOptions&lt;&quot;stream&quot;&gt;): Promise&lt;ReadableStream | null&gt;;&#10;    get(key: Array&lt;Key&gt;, type: &quot;text&quot;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;json&quot;): Promise&lt;Map&lt;string, ExpectedValue | null&gt;&gt;;&#10;    get(key: Array&lt;Key&gt;, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;Map&lt;string, string | null&gt;&gt;;&#10;    get&lt;ExpectedValue = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;Map&lt;string, ExpectedValue | null&gt;&gt;;&#10;    list&lt;Metadata = unknown&gt;(options?: KVNamespaceListOptions): Promise&lt;KVNamespaceListResult&lt;Metadata, Key&gt;&gt;;&#10;    put(key: Key, value: string | ArrayBuffer | ArrayBufferView | ReadableStream, options?: KVNamespacePutOptions): Promise&lt;void&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;text&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Key, type: &quot;json&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;arrayBuffer&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ArrayBuffer, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, type: &quot;stream&quot;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ReadableStream, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;arrayBuffer&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ArrayBuffer, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Key, options: KVNamespaceGetOptions&lt;&quot;stream&quot;&gt;): Promise&lt;KVNamespaceGetWithMetadataResult&lt;ReadableStream, Metadata&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;text&quot;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Array&lt;Key&gt;, type: &quot;json&quot;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: Partial&lt;KVNamespaceGetOptions&lt;undefined&gt;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;text&quot;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;string, Metadata&gt;&gt;&gt;;&#10;    getWithMetadata&lt;ExpectedValue = unknown, Metadata = unknown&gt;(key: Array&lt;Key&gt;, options?: KVNamespaceGetOptions&lt;&quot;json&quot;&gt;): Promise&lt;Map&lt;string, KVNamespaceGetWithMetadataResult&lt;ExpectedValue, Metadata&gt;&gt;&gt;;&#10;    delete(key: Key): Promise&lt;void&gt;;&#10;}&#10;interface KVNamespaceListOptions {&#10;    limit?: number;&#10;    prefix?: (string | null);&#10;    cursor?: (string | null);&#10;}&#10;interface KVNamespaceGetOptions&lt;Type&gt; {&#10;    type: Type;&#10;    cacheTtl?: number;&#10;}&#10;interface KVNamespacePutOptions {&#10;    expiration?: number;&#10;    expirationTtl?: number;&#10;    metadata?: (any | null);&#10;}&#10;interface KVNamespaceGetWithMetadataResult&lt;Value, Metadata&gt; {&#10;    value: Value | null;&#10;    metadata: Metadata | null;&#10;    cacheStatus: string | null;&#10;}&#10;type QueueContentType = &quot;text&quot; | &quot;bytes&quot; | &quot;json&quot; | &quot;v8&quot;;&#10;interface Queue&lt;Body = unknown&gt; {&#10;    send(message: Body, options?: QueueSendOptions): Promise&lt;void&gt;;&#10;    sendBatch(messages: Iterable&lt;MessageSendRequest&lt;Body&gt;&gt;, options?: QueueSendBatchOptions): Promise&lt;void&gt;;&#10;}&#10;interface QueueSendOptions {&#10;    contentType?: QueueContentType;&#10;    delaySeconds?: number;&#10;}&#10;interface QueueSendBatchOptions {&#10;    delaySeconds?: number;&#10;}&#10;interface MessageSendRequest&lt;Body = unknown&gt; {&#10;    body: Body;&#10;    contentType?: QueueContentType;&#10;    delaySeconds?: number;&#10;}&#10;interface QueueRetryOptions {&#10;    delaySeconds?: number;&#10;}&#10;interface Message&lt;Body = unknown&gt; {&#10;    readonly id: string;&#10;    readonly timestamp: Date;&#10;    readonly body: Body;&#10;    readonly attempts: number;&#10;    retry(options?: QueueRetryOptions): void;&#10;    ack(): void;&#10;}&#10;interface QueueEvent&lt;Body = unknown&gt; extends ExtendableEvent {&#10;    readonly messages: readonly Message&lt;Body&gt;[];&#10;    readonly queue: string;&#10;    retryAll(options?: QueueRetryOptions): void;&#10;    ackAll(): void;&#10;}&#10;interface MessageBatch&lt;Body = unknown&gt; {&#10;    readonly messages: readonly Message&lt;Body&gt;[];&#10;    readonly queue: string;&#10;    retryAll(options?: QueueRetryOptions): void;&#10;    ackAll(): void;&#10;}&#10;interface R2Error extends Error {&#10;    readonly name: string;&#10;    readonly code: number;&#10;    readonly message: string;&#10;    readonly action: string;&#10;    readonly stack: any;&#10;}&#10;interface R2ListOptions {&#10;    limit?: number;&#10;    prefix?: string;&#10;    cursor?: string;&#10;    delimiter?: string;&#10;    startAfter?: string;&#10;    include?: (&quot;httpMetadata&quot; | &quot;customMetadata&quot;)[];&#10;}&#10;declare abstract class R2Bucket {&#10;    head(key: string): Promise&lt;R2Object | null&gt;;&#10;    get(key: string, options: R2GetOptions &amp; {&#10;        onlyIf: R2Conditional | Headers;&#10;    }): Promise&lt;R2ObjectBody | R2Object | null&gt;;&#10;    get(key: string, options?: R2GetOptions): Promise&lt;R2ObjectBody | null&gt;;&#10;    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions &amp; {&#10;        onlyIf: R2Conditional | Headers;&#10;    }): Promise&lt;R2Object | null&gt;;&#10;    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions): Promise&lt;R2Object&gt;;&#10;    createMultipartUpload(key: string, options?: R2MultipartOptions): Promise&lt;R2MultipartUpload&gt;;&#10;    resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;&#10;    delete(keys: string | string[]): Promise&lt;void&gt;;&#10;    list(options?: R2ListOptions): Promise&lt;R2Objects&gt;;&#10;}&#10;interface R2MultipartUpload {&#10;    readonly key: string;&#10;    readonly uploadId: string;&#10;    uploadPart(partNumber: number, value: ReadableStream | (ArrayBuffer | ArrayBufferView) | string | Blob, options?: R2UploadPartOptions): Promise&lt;R2UploadedPart&gt;;&#10;    abort(): Promise&lt;void&gt;;&#10;    complete(uploadedParts: R2UploadedPart[]): Promise&lt;R2Object&gt;;&#10;}&#10;interface R2UploadedPart {&#10;    partNumber: number;&#10;    etag: string;&#10;}&#10;declare abstract class R2Object {&#10;    readonly key: string;&#10;    readonly version: string;&#10;    readonly size: number;&#10;    readonly etag: string;&#10;    readonly httpEtag: string;&#10;    readonly checksums: R2Checksums;&#10;    readonly uploaded: Date;&#10;    readonly httpMetadata?: R2HTTPMetadata;&#10;    readonly customMetadata?: Record&lt;string, string&gt;;&#10;    readonly range?: R2Range;&#10;    readonly storageClass: string;&#10;    readonly ssecKeyMd5?: string;&#10;    writeHttpMetadata(headers: Headers): void;&#10;}&#10;interface R2ObjectBody extends R2Object {&#10;    get body(): ReadableStream;&#10;    get bodyUsed(): boolean;&#10;    arrayBuffer(): Promise&lt;ArrayBuffer&gt;;&#10;    bytes(): Promise&lt;Uint8Array&gt;;&#10;    text(): Promise&lt;string&gt;;&#10;    json&lt;T&gt;(): Promise&lt;T&gt;;&#10;    blob(): Promise&lt;Blob&gt;;&#10;}&#10;type R2Range = {&#10;    offset: number;&#10;    length?: number;&#10;} | {&#10;    offset?: number;&#10;    length: number;&#10;} | {&#10;    suffix: number;&#10;};&#10;interface R2Conditional {&#10;    etagMatches?: string;&#10;    etagDoesNotMatch?: string;&#10;    uploadedBefore?: Date;&#10;    uploadedAfter?: Date;&#10;    secondsGranularity?: boolean;&#10;}&#10;interface R2GetOptions {&#10;    onlyIf?: (R2Conditional | Headers);&#10;    range?: (R2Range | Headers);&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2PutOptions {&#10;    onlyIf?: (R2Conditional | Headers);&#10;    httpMetadata?: (R2HTTPMetadata | Headers);&#10;    customMetadata?: Record&lt;string, string&gt;;&#10;    md5?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha1?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha256?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha384?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    sha512?: ((ArrayBuffer | ArrayBufferView) | string);&#10;    storageClass?: string;&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2MultipartOptions {&#10;    httpMetadata?: (R2HTTPMetadata | Headers);&#10;    customMetadata?: Record&lt;string, string&gt;;&#10;    storageClass?: string;&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;interface R2Checksums {&#10;    readonly md5?: ArrayBuffer;&#10;    readonly sha1?: ArrayBuffer;&#10;    readonly sha256?: ArrayBuffer;&#10;    readonly sha384?: ArrayBuffer;&#10;    readonly sha512?: ArrayBuffer;&#10;    toJSON(): R2StringChecksums;&#10;}&#10;interface R2StringChecksums {&#10;    md5?: string;&#10;    sha1?: string;&#10;    sha256?: string;&#10;    sha384?: string;&#10;    sha512?: string;&#10;}&#10;interface R2HTTPMetadata {&#10;    contentType?: string;&#10;    contentLanguage?: string;&#10;    contentDisposition?: string;&#10;    contentEncoding?: string;&#10;    cacheControl?: string;&#10;    cacheExpiry?: Date;&#10;}&#10;type R2Objects = {&#10;    objects: R2Object[];&#10;    delimitedPrefixes: string[];&#10;} &amp; ({&#10;    truncated: true;&#10;    cursor: string;&#10;} | {&#10;    truncated: false;&#10;});&#10;interface R2UploadPartOptions {&#10;    ssecKey?: (ArrayBuffer | string);&#10;}&#10;declare abstract class ScheduledEvent extends ExtendableEvent {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;    noRetry(): void;&#10;}&#10;interface ScheduledController {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;    noRetry(): void;&#10;}&#10;interface QueuingStrategy&lt;T = any&gt; {&#10;    highWaterMark?: (number | bigint);&#10;    size?: (chunk: T) =&gt; number | bigint;&#10;}&#10;interface UnderlyingSink&lt;W = any&gt; {&#10;    type?: string;&#10;    start?: (controller: WritableStreamDefaultController) =&gt; void | Promise&lt;void&gt;;&#10;    write?: (chunk: W, controller: WritableStreamDefaultController) =&gt; void | Promise&lt;void&gt;;&#10;    abort?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    close?: () =&gt; void | Promise&lt;void&gt;;&#10;}&#10;interface UnderlyingByteSource {&#10;    type: &quot;bytes&quot;;&#10;    autoAllocateChunkSize?: number;&#10;    start?: (controller: ReadableByteStreamController) =&gt; void | Promise&lt;void&gt;;&#10;    pull?: (controller: ReadableByteStreamController) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;}&#10;interface UnderlyingSource&lt;R = any&gt; {&#10;    type?: &quot;&quot; | undefined;&#10;    start?: (controller: ReadableStreamDefaultController&lt;R&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    pull?: (controller: ReadableStreamDefaultController&lt;R&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    expectedLength?: (number | bigint);&#10;}&#10;interface Transformer&lt;I = any, O = any&gt; {&#10;    readableType?: string;&#10;    writableType?: string;&#10;    start?: (controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    transform?: (chunk: I, controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    flush?: (controller: TransformStreamDefaultController&lt;O&gt;) =&gt; void | Promise&lt;void&gt;;&#10;    cancel?: (reason: any) =&gt; void | Promise&lt;void&gt;;&#10;    expectedLength?: number;&#10;}&#10;interface StreamPipeOptions {&#10;    /**&#10;     * Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.&#10;     *&#10;     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.&#10;     *&#10;     * Errors and closures of the source and destination streams propagate as follows:&#10;     *&#10;     * An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.&#10;     *&#10;     * An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.&#10;     *&#10;     * When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.&#10;     *&#10;     * If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.&#10;     *&#10;     * The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.&#10;     */&#10;    preventClose?: boolean;&#10;    preventAbort?: boolean;&#10;    preventCancel?: boolean;&#10;    signal?: AbortSignal;&#10;}&#10;type ReadableStreamReadResult&lt;R = any&gt; = {&#10;    done: false;&#10;    value: R;&#10;} | {&#10;    done: true;&#10;    value?: undefined;&#10;};&#10;/**&#10; * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)&#10; */&#10;interface ReadableStream&lt;R = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/locked) */&#10;    get locked(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/cancel) */&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */&#10;    getReader(): ReadableStreamDefaultReader&lt;R&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */&#10;    getReader(options: ReadableStreamGetReaderOptions): ReadableStreamBYOBReader;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeThrough) */&#10;    pipeThrough&lt;T&gt;(transform: ReadableWritablePair&lt;T, R&gt;, options?: StreamPipeOptions): ReadableStream&lt;T&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeTo) */&#10;    pipeTo(destination: WritableStream&lt;R&gt;, options?: StreamPipeOptions): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/tee) */&#10;    tee(): [&#10;        ReadableStream&lt;R&gt;,&#10;        ReadableStream&lt;R&gt;&#10;    ];&#10;    values(options?: ReadableStreamValuesOptions): AsyncIterableIterator&lt;R&gt;;&#10;    [Symbol.asyncIterator](options?: ReadableStreamValuesOptions): AsyncIterableIterator&lt;R&gt;;&#10;}&#10;/**&#10; * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)&#10; */&#10;declare const ReadableStream: {&#10;    prototype: ReadableStream;&#10;    new (underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy&lt;Uint8Array&gt;): ReadableStream&lt;Uint8Array&gt;;&#10;    new &lt;R = any&gt;(underlyingSource?: UnderlyingSource&lt;R&gt;, strategy?: QueuingStrategy&lt;R&gt;): ReadableStream&lt;R&gt;;&#10;};&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */&#10;declare class ReadableStreamDefaultReader&lt;R = any&gt; {&#10;    constructor(stream: ReadableStream);&#10;    get closed(): Promise&lt;void&gt;;&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/read) */&#10;    read(): Promise&lt;ReadableStreamReadResult&lt;R&gt;&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/releaseLock) */&#10;    releaseLock(): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */&#10;declare class ReadableStreamBYOBReader {&#10;    constructor(stream: ReadableStream);&#10;    get closed(): Promise&lt;void&gt;;&#10;    cancel(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */&#10;    read&lt;T extends ArrayBufferView&gt;(view: T): Promise&lt;ReadableStreamReadResult&lt;T&gt;&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */&#10;    releaseLock(): void;&#10;    readAtLeast&lt;T extends ArrayBufferView&gt;(minElements: number, view: T): Promise&lt;ReadableStreamReadResult&lt;T&gt;&gt;;&#10;}&#10;interface ReadableStreamBYOBReaderReadableStreamBYOBReaderReadOptions {&#10;    min?: number;&#10;}&#10;interface ReadableStreamGetReaderOptions {&#10;    /**&#10;     * Creates a ReadableStreamBYOBReader and locks the stream to the new reader.&#10;     *&#10;     * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle &quot;bring your own buffer&quot; reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.&#10;     */&#10;    mode: &quot;byob&quot;;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */&#10;declare abstract class ReadableStreamBYOBRequest {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */&#10;    get view(): Uint8Array | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */&#10;    respond(bytesWritten: number): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */&#10;    respondWithNewView(view: ArrayBuffer | ArrayBufferView): void;&#10;    get atLeast(): number | null;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */&#10;declare abstract class ReadableStreamDefaultController&lt;R = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/close) */&#10;    close(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/enqueue) */&#10;    enqueue(chunk?: R): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/error) */&#10;    error(reason: any): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */&#10;declare abstract class ReadableByteStreamController {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/byobRequest) */&#10;    get byobRequest(): ReadableStreamBYOBRequest | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/close) */&#10;    close(): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/enqueue) */&#10;    enqueue(chunk: ArrayBuffer | ArrayBufferView): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/error) */&#10;    error(reason: any): void;&#10;}&#10;/**&#10; * This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)&#10; */&#10;declare abstract class WritableStreamDefaultController {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/signal) */&#10;    get signal(): AbortSignal;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/error) */&#10;    error(reason?: any): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */&#10;declare abstract class TransformStreamDefaultController&lt;O = any&gt; {&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/enqueue) */&#10;    enqueue(chunk?: O): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/error) */&#10;    error(reason: any): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/terminate) */&#10;    terminate(): void;&#10;}&#10;interface ReadableWritablePair&lt;R = any, W = any&gt; {&#10;    /**&#10;     * Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.&#10;     *&#10;     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.&#10;     */&#10;    writable: WritableStream&lt;W&gt;;&#10;    readable: ReadableStream&lt;R&gt;;&#10;}&#10;/**&#10; * This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)&#10; */&#10;declare class WritableStream&lt;W = any&gt; {&#10;    constructor(underlyingSink?: UnderlyingSink, queuingStrategy?: QueuingStrategy);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/locked) */&#10;    get locked(): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/abort) */&#10;    abort(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/close) */&#10;    close(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/getWriter) */&#10;    getWriter(): WritableStreamDefaultWriter&lt;W&gt;;&#10;}&#10;/**&#10; * This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the &lt; writer to the WritableStream ensuring that no other streams can write to the underlying sink.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)&#10; */&#10;declare class WritableStreamDefaultWriter&lt;W = any&gt; {&#10;    constructor(stream: WritableStream);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/closed) */&#10;    get closed(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/ready) */&#10;    get ready(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/desiredSize) */&#10;    get desiredSize(): number | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/abort) */&#10;    abort(reason?: any): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/close) */&#10;    close(): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/write) */&#10;    write(chunk?: W): Promise&lt;void&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/releaseLock) */&#10;    releaseLock(): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */&#10;declare class TransformStream&lt;I = any, O = any&gt; {&#10;    constructor(transformer?: Transformer&lt;I, O&gt;, writableStrategy?: QueuingStrategy&lt;I&gt;, readableStrategy?: QueuingStrategy&lt;O&gt;);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/readable) */&#10;    get readable(): ReadableStream&lt;O&gt;;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/writable) */&#10;    get writable(): WritableStream&lt;I&gt;;&#10;}&#10;declare class FixedLengthStream extends IdentityTransformStream {&#10;    constructor(expectedLength: number | bigint, queuingStrategy?: IdentityTransformStreamQueuingStrategy);&#10;}&#10;declare class IdentityTransformStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(queuingStrategy?: IdentityTransformStreamQueuingStrategy);&#10;}&#10;interface IdentityTransformStreamQueuingStrategy {&#10;    highWaterMark?: (number | bigint);&#10;}&#10;interface ReadableStreamValuesOptions {&#10;    preventCancel?: boolean;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */&#10;declare class CompressionStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(format: &quot;gzip&quot; | &quot;deflate&quot; | &quot;deflate-raw&quot;);&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */&#10;declare class DecompressionStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, Uint8Array&gt; {&#10;    constructor(format: &quot;gzip&quot; | &quot;deflate&quot; | &quot;deflate-raw&quot;);&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */&#10;declare class TextEncoderStream extends TransformStream&lt;string, Uint8Array&gt; {&#10;    constructor();&#10;    get encoding(): string;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */&#10;declare class TextDecoderStream extends TransformStream&lt;ArrayBuffer | ArrayBufferView, string&gt; {&#10;    constructor(label?: string, options?: TextDecoderStreamTextDecoderStreamInit);&#10;    get encoding(): string;&#10;    get fatal(): boolean;&#10;    get ignoreBOM(): boolean;&#10;}&#10;interface TextDecoderStreamTextDecoderStreamInit {&#10;    fatal?: boolean;&#10;    ignoreBOM?: boolean;&#10;}&#10;/**&#10; * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)&#10; */&#10;declare class ByteLengthQueuingStrategy implements QueuingStrategy&lt;ArrayBufferView&gt; {&#10;    constructor(init: QueuingStrategyInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/highWaterMark) */&#10;    get highWaterMark(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/size) */&#10;    get size(): (chunk?: any) =&gt; number;&#10;}&#10;/**&#10; * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)&#10; */&#10;declare class CountQueuingStrategy implements QueuingStrategy {&#10;    constructor(init: QueuingStrategyInit);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/highWaterMark) */&#10;    get highWaterMark(): number;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/size) */&#10;    get size(): (chunk?: any) =&gt; number;&#10;}&#10;interface QueuingStrategyInit {&#10;    /**&#10;     * Creates a new ByteLengthQueuingStrategy with the provided high water mark.&#10;     *&#10;     * Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.&#10;     */&#10;    highWaterMark: number;&#10;}&#10;interface ScriptVersion {&#10;    id?: string;&#10;    tag?: string;&#10;    message?: string;&#10;}&#10;declare abstract class TailEvent extends ExtendableEvent {&#10;    readonly events: TraceItem[];&#10;    readonly traces: TraceItem[];&#10;}&#10;interface TraceItem {&#10;    readonly event: (TraceItemFetchEventInfo | TraceItemJsRpcEventInfo | TraceItemScheduledEventInfo | TraceItemAlarmEventInfo | TraceItemQueueEventInfo | TraceItemEmailEventInfo | TraceItemTailEventInfo | TraceItemCustomEventInfo | TraceItemHibernatableWebSocketEventInfo) | null;&#10;    readonly eventTimestamp: number | null;&#10;    readonly logs: TraceLog[];&#10;    readonly exceptions: TraceException[];&#10;    readonly diagnosticsChannelEvents: TraceDiagnosticChannelEvent[];&#10;    readonly scriptName: string | null;&#10;    readonly entrypoint?: string;&#10;    readonly scriptVersion?: ScriptVersion;&#10;    readonly dispatchNamespace?: string;&#10;    readonly scriptTags?: string[];&#10;    readonly outcome: string;&#10;    readonly executionModel: string;&#10;    readonly truncated: boolean;&#10;    readonly cpuTime: number;&#10;    readonly wallTime: number;&#10;}&#10;interface TraceItemAlarmEventInfo {&#10;    readonly scheduledTime: Date;&#10;}&#10;interface TraceItemCustomEventInfo {&#10;}&#10;interface TraceItemScheduledEventInfo {&#10;    readonly scheduledTime: number;&#10;    readonly cron: string;&#10;}&#10;interface TraceItemQueueEventInfo {&#10;    readonly queue: string;&#10;    readonly batchSize: number;&#10;}&#10;interface TraceItemEmailEventInfo {&#10;    readonly mailFrom: string;&#10;    readonly rcptTo: string;&#10;    readonly rawSize: number;&#10;}&#10;interface TraceItemTailEventInfo {&#10;    readonly consumedEvents: TraceItemTailEventInfoTailItem[];&#10;}&#10;interface TraceItemTailEventInfoTailItem {&#10;    readonly scriptName: string | null;&#10;}&#10;interface TraceItemFetchEventInfo {&#10;    readonly response?: TraceItemFetchEventInfoResponse;&#10;    readonly request: TraceItemFetchEventInfoRequest;&#10;}&#10;interface TraceItemFetchEventInfoRequest {&#10;    readonly cf?: any;&#10;    readonly headers: Record&lt;string, string&gt;;&#10;    readonly method: string;&#10;    readonly url: string;&#10;    getUnredacted(): TraceItemFetchEventInfoRequest;&#10;}&#10;interface TraceItemFetchEventInfoResponse {&#10;    readonly status: number;&#10;}&#10;interface TraceItemJsRpcEventInfo {&#10;    readonly rpcMethod: string;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfo {&#10;    readonly getWebSocketEvent: TraceItemHibernatableWebSocketEventInfoMessage | TraceItemHibernatableWebSocketEventInfoClose | TraceItemHibernatableWebSocketEventInfoError;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoMessage {&#10;    readonly webSocketEventType: string;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoClose {&#10;    readonly webSocketEventType: string;&#10;    readonly code: number;&#10;    readonly wasClean: boolean;&#10;}&#10;interface TraceItemHibernatableWebSocketEventInfoError {&#10;    readonly webSocketEventType: string;&#10;}&#10;interface TraceLog {&#10;    readonly timestamp: number;&#10;    readonly level: string;&#10;    readonly message: any;&#10;}&#10;interface TraceException {&#10;    readonly timestamp: number;&#10;    readonly message: string;&#10;    readonly name: string;&#10;    readonly stack?: string;&#10;}&#10;interface TraceDiagnosticChannelEvent {&#10;    readonly timestamp: number;&#10;    readonly channel: string;&#10;    readonly message: any;&#10;}&#10;interface TraceMetrics {&#10;    readonly cpuTime: number;&#10;    readonly wallTime: number;&#10;}&#10;interface UnsafeTraceMetrics {&#10;    fromTrace(item: TraceItem): TraceMetrics;&#10;}&#10;/**&#10; * The URL interface represents an object providing static methods used for creating object URLs.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)&#10; */&#10;declare class URL {&#10;    constructor(url: string | URL, base?: string | URL);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/origin) */&#10;    get origin(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */&#10;    get href(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */&#10;    set href(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */&#10;    get protocol(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */&#10;    set protocol(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */&#10;    get username(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */&#10;    set username(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */&#10;    get password(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */&#10;    set password(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */&#10;    get host(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */&#10;    set host(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */&#10;    get hostname(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */&#10;    set hostname(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */&#10;    get port(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */&#10;    set port(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */&#10;    get pathname(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */&#10;    set pathname(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */&#10;    get search(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */&#10;    set search(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */&#10;    get hash(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */&#10;    set hash(value: string);&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/searchParams) */&#10;    get searchParams(): URLSearchParams;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/toJSON) */&#10;    toJSON(): string;&#10;    /*function toString() { [native code] }*/&#10;    toString(): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/canParse_static) */&#10;    static canParse(url: string, base?: string): boolean;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/parse_static) */&#10;    static parse(url: string, base?: string): URL | null;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/createObjectURL_static) */&#10;    static createObjectURL(object: File | Blob): string;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/revokeObjectURL_static) */&#10;    static revokeObjectURL(object_url: string): void;&#10;}&#10;/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */&#10;declare class URLSearchParams {&#10;    constructor(init?: (Iterable&lt;Iterable&lt;string&gt;&gt; | Record&lt;string, string&gt; | string));&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/size) */&#10;    get size(): number;&#10;    /**&#10;     * Appends a specified key/value pair as a new search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/append)&#10;     */&#10;    append(name: string, value: string): void;&#10;    /**&#10;     * Deletes the given search parameter, and its associated value, from the list of all search parameters.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/delete)&#10;     */&#10;    delete(name: string, value?: string): void;&#10;    /**&#10;     * Returns the first value associated to the given search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/get)&#10;     */&#10;    get(name: string): string | null;&#10;    /**&#10;     * Returns all the values association with a given search parameter.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/getAll)&#10;     */&#10;    getAll(name: string): string[];&#10;    /**&#10;     * Returns a Boolean indicating if such a search parameter exists.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/has)&#10;     */&#10;    has(name: string, value?: string): boolean;&#10;    /**&#10;     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/set)&#10;     */&#10;    set(name: string, value: string): void;&#10;    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/sort) */&#10;    sort(): void;&#10;    /* Returns an array of key, value pairs for every entry in the search params. */&#10;    entries(): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;    /* Returns a list of keys in the search params. */&#10;    keys(): IterableIterator&lt;string&gt;;&#10;    /* Returns a list of values in the search params. */&#10;    values(): IterableIterator&lt;string&gt;;&#10;    forEach&lt;This = unknown&gt;(callback: (this: This, value: string, key: string, parent: URLSearchParams) =&gt; void, thisArg?: This): void;&#10;    /*function toString() { [native code] } Returns a string containing a query string suitable for use in a URL. Does not include the question mark. */&#10;    toString(): string;&#10;    [Symbol.iterator](): IterableIterator&lt;[&#10;        key: string,&#10;        value: string&#10;    ]&gt;;&#10;}&#10;declare class URLPattern {&#10;    constructor(input?: (string | URLPatternInit), baseURL?: (string | URLPatternOptions), patternOptions?: URLPatternOptions);&#10;    get protocol(): string;&#10;    get username(): string;&#10;    get password(): string;&#10;    get hostname(): string;&#10;    get port(): string;&#10;    get pathname(): string;&#10;    get search(): string;&#10;    get hash(): string;&#10;    get hasRegExpGroups(): boolean;&#10;    test(input?: (string | URLPatternInit), baseURL?: string): boolean;&#10;    exec(input?: (string | URLPatternInit), baseURL?: string): URLPatternResult | null;&#10;}&#10;interface URLPatternInit {&#10;    protocol?: string;&#10;    username?: string;&#10;    password?: string;&#10;    hostname?: string;&#10;    port?: string;&#10;    pathname?: string;&#10;    search?: string;&#10;    hash?: string;&#10;    baseURL?: string;&#10;}&#10;interface URLPatternComponentResult {&#10;    input: string;&#10;    groups: Record&lt;string, string&gt;;&#10;}&#10;interface URLPatternResult {&#10;    inputs: (string | URLPatternInit)[];&#10;    protocol: URLPatternComponentResult;&#10;    username: URLPatternComponentResult;&#10;    password: URLPatternComponentResult;&#10;    hostname: URLPatternComponentResult;&#10;    port: URLPatternComponentResult;&#10;    pathname: URLPatternComponentResult;&#10;    search: URLPatternComponentResult;&#10;    hash: URLPatternComponentResult;&#10;}&#10;interface URLPatternOptions {&#10;    ignoreCase?: boolean;&#10;}&#10;/**&#10; * A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)&#10; */&#10;declare class CloseEvent extends Event {&#10;    constructor(type: string, initializer?: CloseEventInit);&#10;    /**&#10;     * Returns the WebSocket connection close code provided by the server.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/code)&#10;     */&#10;    readonly code: number;&#10;    /**&#10;     * Returns the WebSocket connection close reason provided by the server.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/reason)&#10;     */&#10;    readonly reason: string;&#10;    /**&#10;     * Returns true if the connection closed cleanly; false otherwise.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/wasClean)&#10;     */&#10;    readonly wasClean: boolean;&#10;}&#10;interface CloseEventInit {&#10;    code?: number;&#10;    reason?: string;&#10;    wasClean?: boolean;&#10;}&#10;type WebSocketEventMap = {&#10;    close: CloseEvent;&#10;    message: MessageEvent;&#10;    open: Event;&#10;    error: ErrorEvent;&#10;};&#10;/**&#10; * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)&#10; */&#10;declare var WebSocket: {&#10;    prototype: WebSocket;&#10;    new (url: string, protocols?: (string[] | string)): WebSocket;&#10;    readonly READY_STATE_CONNECTING: number;&#10;    readonly CONNECTING: number;&#10;    readonly READY_STATE_OPEN: number;&#10;    readonly OPEN: number;&#10;    readonly READY_STATE_CLOSING: number;&#10;    readonly CLOSING: number;&#10;    readonly READY_STATE_CLOSED: number;&#10;    readonly CLOSED: number;&#10;};&#10;/**&#10; * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.&#10; *&#10; * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)&#10; */&#10;interface WebSocket extends EventTarget&lt;WebSocketEventMap&gt; {&#10;    accept(): void;&#10;    /**&#10;     * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/send)&#10;     */&#10;    send(message: (ArrayBuffer | ArrayBufferView) | string): void;&#10;    /**&#10;     * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/close)&#10;     */&#10;    close(code?: number, reason?: string): void;&#10;    serializeAttachment(attachment: any): void;&#10;    deserializeAttachment(): any | null;&#10;    /**&#10;     * Returns the state of the WebSocket object's connection. It can have the values described below.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/readyState)&#10;     */&#10;    readyState: number;&#10;    /**&#10;     * Returns the URL that was used to establish the WebSocket connection.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/url)&#10;     */&#10;    url: string | null;&#10;    /**&#10;     * Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/protocol)&#10;     */&#10;    protocol: string | null;&#10;    /**&#10;     * Returns the extensions selected by the server, if any.&#10;     *&#10;     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/extensions)&#10;     */&#10;    extensions: string | null;&#10;}&#10;declare const WebSocketPair: {&#10;    new (): {&#10;        0: WebSocket;&#10;        1: WebSocket;&#10;    };&#10;};&#10;interface SqlStorage {&#10;    exec&lt;T extends Record&lt;string, SqlStorageValue&gt;&gt;(query: string, ...bindings: any[]): SqlStorageCursor&lt;T&gt;;&#10;    get databaseSize(): number;&#10;    Cursor: typeof SqlStorageCursor;&#10;    Statement: typeof SqlStorageStatement;&#10;}&#10;declare abstract class SqlStorageStatement {&#10;}&#10;type SqlStorageValue = ArrayBuffer | string | number | null;&#10;declare abstract class SqlStorageCursor&lt;T extends Record&lt;string, SqlStorageValue&gt;&gt; {&#10;    next(): {&#10;        done?: false;&#10;        value: T;&#10;    } | {&#10;        done: true;&#10;        value?: never;&#10;    };&#10;    toArray(): T[];&#10;    one(): T;&#10;    raw&lt;U extends SqlStorageValue[]&gt;(): IterableIterator&lt;U&gt;;&#10;    columnNames: string[];&#10;    get rowsRead(): number;&#10;    get rowsWritten(): number;&#10;    [Symbol.iterator](): IterableIterator&lt;T&gt;;&#10;}&#10;interface SecretsStoreSecret {&#10;    /**&#10;     * Get a secret from the Secrets Store, returning a string of the secret value&#10;     * if it exists, or throws an error if it does not exist&#10;     */&#10;    get(): Promise&lt;string&gt;;&#10;}&#10;declare module &quot;cloudflare:pipelines&quot; {&#10;    export abstract class PipelineTransformationEntrypoint&lt;Env = unknown, I extends PipelineRecord = PipelineRecord, O extends PipelineRecord = PipelineRecord&gt; {&#10;        protected env: Env;&#10;        protected ctx: ExecutionContext;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        /**&#10;         * run recieves an array of PipelineRecord which can be&#10;         * transformed and returned to the pipeline&#10;         * @param records Incoming records from the pipeline to be transformed&#10;         * @param metadata Information about the specific pipeline calling the transformation entrypoint&#10;         * @returns A promise containing the transformed PipelineRecord array&#10;         */&#10;        public run(records: I[], metadata: PipelineBatchMetadata): Promise&lt;O[]&gt;;&#10;    }&#10;    export type PipelineRecord = Record&lt;string, unknown&gt;;&#10;    export type PipelineBatchMetadata = {&#10;        pipelineId: string;&#10;        pipelineName: string;&#10;    };&#10;    export interface Pipeline&lt;T extends PipelineRecord = PipelineRecord&gt; {&#10;        /**&#10;         * The Pipeline interface represents the type of a binding to a Pipeline&#10;         *&#10;         * @param records The records to send to the pipeline&#10;         */&#10;        send(records: T[]): Promise&lt;void&gt;;&#10;    }&#10;}&#10;// PubSubMessage represents an incoming PubSub message.&#10;// The message includes metadata about the broker, the client, and the payload&#10;// itself.&#10;// https://developers.cloudflare.com/pub-sub/&#10;interface PubSubMessage {&#10;    // Message ID&#10;    readonly mid: number;&#10;    // MQTT broker FQDN in the form mqtts://BROKER.NAMESPACE.cloudflarepubsub.com:PORT&#10;    readonly broker: string;&#10;    // The MQTT topic the message was sent on.&#10;    readonly topic: string;&#10;    // The client ID of the client that published this message.&#10;    readonly clientId: string;&#10;    // The unique identifier (JWT ID) used by the client to authenticate, if token&#10;    // auth was used.&#10;    readonly jti?: string;&#10;    // A Unix timestamp (seconds from Jan 1, 1970), set when the Pub/Sub Broker&#10;    // received the message from the client.&#10;    readonly receivedAt: number;&#10;    // An (optional) string with the MIME type of the payload, if set by the&#10;    // client.&#10;    readonly contentType: string;&#10;    // Set to 1 when the payload is a UTF-8 string&#10;    // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901063&#10;    readonly payloadFormatIndicator: number;&#10;    // Pub/Sub (MQTT) payloads can be UTF-8 strings, or byte arrays.&#10;    // You can use payloadFormatIndicator to inspect this before decoding.&#10;    payload: string | Uint8Array;&#10;}&#10;// JsonWebKey extended by kid parameter&#10;interface JsonWebKeyWithKid extends JsonWebKey {&#10;    // Key Identifier of the JWK&#10;    readonly kid: string;&#10;}&#10;interface RateLimitOptions {&#10;    key: string;&#10;}&#10;interface RateLimitOutcome {&#10;    success: boolean;&#10;}&#10;interface RateLimit {&#10;    /**&#10;     * Rate limit a request based on the provided options.&#10;     * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/&#10;     * @returns A promise that resolves with the outcome of the rate limit.&#10;     */&#10;    limit(options: RateLimitOptions): Promise&lt;RateLimitOutcome&gt;;&#10;}&#10;// Namespace for RPC utility types. Unfortunately, we can't use a `module` here as these types need&#10;// to referenced by `Fetcher`. This is included in the &quot;importable&quot; version of the types which&#10;// strips all `module` blocks.&#10;declare namespace Rpc {&#10;    // Branded types for identifying `WorkerEntrypoint`/`DurableObject`/`Target`s.&#10;    // TypeScript uses *structural* typing meaning anything with the same shape as type `T` is a `T`.&#10;    // For the classes exported by `cloudflare:workers` we want *nominal* typing (i.e. we only want to&#10;    // accept `WorkerEntrypoint` from `cloudflare:workers`, not any other class with the same shape)&#10;    export const __RPC_STUB_BRAND: '__RPC_STUB_BRAND';&#10;    export const __RPC_TARGET_BRAND: '__RPC_TARGET_BRAND';&#10;    export const __WORKER_ENTRYPOINT_BRAND: '__WORKER_ENTRYPOINT_BRAND';&#10;    export const __DURABLE_OBJECT_BRAND: '__DURABLE_OBJECT_BRAND';&#10;    export const __WORKFLOW_ENTRYPOINT_BRAND: '__WORKFLOW_ENTRYPOINT_BRAND';&#10;    export interface RpcTargetBranded {&#10;        [__RPC_TARGET_BRAND]: never;&#10;    }&#10;    export interface WorkerEntrypointBranded {&#10;        [__WORKER_ENTRYPOINT_BRAND]: never;&#10;    }&#10;    export interface DurableObjectBranded {&#10;        [__DURABLE_OBJECT_BRAND]: never;&#10;    }&#10;    export interface WorkflowEntrypointBranded {&#10;        [__WORKFLOW_ENTRYPOINT_BRAND]: never;&#10;    }&#10;    export type EntrypointBranded = WorkerEntrypointBranded | DurableObjectBranded | WorkflowEntrypointBranded;&#10;    // Types that can be used through `Stub`s&#10;    export type Stubable = RpcTargetBranded | ((...args: any[]) =&gt; any);&#10;    // Types that can be passed over RPC&#10;    // The reason for using a generic type here is to build a serializable subset of structured&#10;    //   cloneable composite types. This allows types defined with the &quot;interface&quot; keyword to pass the&#10;    //   serializable check as well. Otherwise, only types defined with the &quot;type&quot; keyword would pass.&#10;    type Serializable&lt;T&gt; =&#10;    // Structured cloneables&#10;    BaseType&#10;    // Structured cloneable composites&#10;     | Map&lt;T extends Map&lt;infer U, unknown&gt; ? Serializable&lt;U&gt; : never, T extends Map&lt;unknown, infer U&gt; ? Serializable&lt;U&gt; : never&gt; | Set&lt;T extends Set&lt;infer U&gt; ? Serializable&lt;U&gt; : never&gt; | ReadonlyArray&lt;T extends ReadonlyArray&lt;infer U&gt; ? Serializable&lt;U&gt; : never&gt; | {&#10;        [K in keyof T]: K extends number | string ? Serializable&lt;T[K]&gt; : never;&#10;    }&#10;    // Special types&#10;     | Stub&lt;Stubable&gt;&#10;    // Serialized as stubs, see `Stubify`&#10;     | Stubable;&#10;    // Base type for all RPC stubs, including common memory management methods.&#10;    // `T` is used as a marker type for unwrapping `Stub`s later.&#10;    interface StubBase&lt;T extends Stubable&gt; extends Disposable {&#10;        [__RPC_STUB_BRAND]: T;&#10;        dup(): this;&#10;    }&#10;    export type Stub&lt;T extends Stubable&gt; = Provider&lt;T&gt; &amp; StubBase&lt;T&gt;;&#10;    // This represents all the types that can be sent as-is over an RPC boundary&#10;    type BaseType = void | undefined | null | boolean | number | bigint | string | TypedArray | ArrayBuffer | DataView | Date | Error | RegExp | ReadableStream&lt;Uint8Array&gt; | WritableStream&lt;Uint8Array&gt; | Request | Response | Headers;&#10;    // Recursively rewrite all `Stubable` types with `Stub`s&#10;    // prettier-ignore&#10;    type Stubify&lt;T&gt; = T extends Stubable ? Stub&lt;T&gt; : T extends Map&lt;infer K, infer V&gt; ? Map&lt;Stubify&lt;K&gt;, Stubify&lt;V&gt;&gt; : T extends Set&lt;infer V&gt; ? Set&lt;Stubify&lt;V&gt;&gt; : T extends Array&lt;infer V&gt; ? Array&lt;Stubify&lt;V&gt;&gt; : T extends ReadonlyArray&lt;infer V&gt; ? ReadonlyArray&lt;Stubify&lt;V&gt;&gt; : T extends BaseType ? T : T extends {&#10;        [key: string | number]: any;&#10;    } ? {&#10;        [K in keyof T]: Stubify&lt;T[K]&gt;;&#10;    } : T;&#10;    // Recursively rewrite all `Stub&lt;T&gt;`s with the corresponding `T`s.&#10;    // Note we use `StubBase` instead of `Stub` here to avoid circular dependencies:&#10;    // `Stub` depends on `Provider`, which depends on `Unstubify`, which would depend on `Stub`.&#10;    // prettier-ignore&#10;    type Unstubify&lt;T&gt; = T extends StubBase&lt;infer V&gt; ? V : T extends Map&lt;infer K, infer V&gt; ? Map&lt;Unstubify&lt;K&gt;, Unstubify&lt;V&gt;&gt; : T extends Set&lt;infer V&gt; ? Set&lt;Unstubify&lt;V&gt;&gt; : T extends Array&lt;infer V&gt; ? Array&lt;Unstubify&lt;V&gt;&gt; : T extends ReadonlyArray&lt;infer V&gt; ? ReadonlyArray&lt;Unstubify&lt;V&gt;&gt; : T extends BaseType ? T : T extends {&#10;        [key: string | number]: unknown;&#10;    } ? {&#10;        [K in keyof T]: Unstubify&lt;T[K]&gt;;&#10;    } : T;&#10;    type UnstubifyAll&lt;A extends any[]&gt; = {&#10;        [I in keyof A]: Unstubify&lt;A[I]&gt;;&#10;    };&#10;    // Utility type for adding `Provider`/`Disposable`s to `object` types only.&#10;    // Note `unknown &amp; T` is equivalent to `T`.&#10;    type MaybeProvider&lt;T&gt; = T extends object ? Provider&lt;T&gt; : unknown;&#10;    type MaybeDisposable&lt;T&gt; = T extends object ? Disposable : unknown;&#10;    // Type for method return or property on an RPC interface.&#10;    // - Stubable types are replaced by stubs.&#10;    // - Serializable types are passed by value, with stubable types replaced by stubs&#10;    //   and a top-level `Disposer`.&#10;    // Everything else can't be passed over PRC.&#10;    // Technically, we use custom thenables here, but they quack like `Promise`s.&#10;    // Intersecting with `(Maybe)Provider` allows pipelining.&#10;    // prettier-ignore&#10;    type Result&lt;R&gt; = R extends Stubable ? Promise&lt;Stub&lt;R&gt;&gt; &amp; Provider&lt;R&gt; : R extends Serializable&lt;R&gt; ? Promise&lt;Stubify&lt;R&gt; &amp; MaybeDisposable&lt;R&gt;&gt; &amp; MaybeProvider&lt;R&gt; : never;&#10;    // Type for method or property on an RPC interface.&#10;    // For methods, unwrap `Stub`s in parameters, and rewrite returns to be `Result`s.&#10;    // Unwrapping `Stub`s allows calling with `Stubable` arguments.&#10;    // For properties, rewrite types to be `Result`s.&#10;    // In each case, unwrap `Promise`s.&#10;    type MethodOrProperty&lt;V&gt; = V extends (...args: infer P) =&gt; infer R ? (...args: UnstubifyAll&lt;P&gt;) =&gt; Result&lt;Awaited&lt;R&gt;&gt; : Result&lt;Awaited&lt;V&gt;&gt;;&#10;    // Type for the callable part of an `Provider` if `T` is callable.&#10;    // This is intersected with methods/properties.&#10;    type MaybeCallableProvider&lt;T&gt; = T extends (...args: any[]) =&gt; any ? MethodOrProperty&lt;T&gt; : unknown;&#10;    // Base type for all other types providing RPC-like interfaces.&#10;    // Rewrites all methods/properties to be `MethodOrProperty`s, while preserving callable types.&#10;    // `Reserved` names (e.g. stub method names like `dup()`) and symbols can't be accessed over RPC.&#10;    // prettier-ignore&#10;    type Provider&lt;T extends object, Reserved extends string = never&gt; = MaybeCallableProvider&lt;T&gt; &amp; {&#10;        [K in Exclude&lt;keyof T, Reserved | symbol | keyof StubBase&lt;never&gt;&gt;]: MethodOrProperty&lt;T[K]&gt;;&#10;    };&#10;}&#10;declare namespace Cloudflare {&#10;    interface Env {&#10;    }&#10;}&#10;declare module &quot;cloudflare:workers&quot; {&#10;    export type RpcStub&lt;T extends Rpc.Stubable&gt; = Rpc.Stub&lt;T&gt;;&#10;    export const RpcStub: {&#10;        new &lt;T extends Rpc.Stubable&gt;(value: T): Rpc.Stub&lt;T&gt;;&#10;    };&#10;    export abstract class RpcTarget implements Rpc.RpcTargetBranded {&#10;        [Rpc.__RPC_TARGET_BRAND]: never;&#10;    }&#10;    // `protected` fields don't appear in `keyof`s, so can't be accessed over RPC&#10;    export abstract class WorkerEntrypoint&lt;Env = unknown&gt; implements Rpc.WorkerEntrypointBranded {&#10;        [Rpc.__WORKER_ENTRYPOINT_BRAND]: never;&#10;        protected ctx: ExecutionContext;&#10;        protected env: Env;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        fetch?(request: Request): Response | Promise&lt;Response&gt;;&#10;        tail?(events: TraceItem[]): void | Promise&lt;void&gt;;&#10;        trace?(traces: TraceItem[]): void | Promise&lt;void&gt;;&#10;        scheduled?(controller: ScheduledController): void | Promise&lt;void&gt;;&#10;        queue?(batch: MessageBatch&lt;unknown&gt;): void | Promise&lt;void&gt;;&#10;        test?(controller: TestController): void | Promise&lt;void&gt;;&#10;    }&#10;    export abstract class DurableObject&lt;Env = unknown&gt; implements Rpc.DurableObjectBranded {&#10;        [Rpc.__DURABLE_OBJECT_BRAND]: never;&#10;        protected ctx: DurableObjectState;&#10;        protected env: Env;&#10;        constructor(ctx: DurableObjectState, env: Env);&#10;        fetch?(request: Request): Response | Promise&lt;Response&gt;;&#10;        alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise&lt;void&gt;;&#10;        webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise&lt;void&gt;;&#10;        webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise&lt;void&gt;;&#10;        webSocketError?(ws: WebSocket, error: unknown): void | Promise&lt;void&gt;;&#10;    }&#10;    export type WorkflowDurationLabel = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';&#10;    export type WorkflowSleepDuration = `${number} ${WorkflowDurationLabel}${'s' | ''}` | number;&#10;    export type WorkflowDelayDuration = WorkflowSleepDuration;&#10;    export type WorkflowTimeoutDuration = WorkflowSleepDuration;&#10;    export type WorkflowRetentionDuration = WorkflowSleepDuration;&#10;    export type WorkflowBackoff = 'constant' | 'linear' | 'exponential';&#10;    export type WorkflowStepConfig = {&#10;        retries?: {&#10;            limit: number;&#10;            delay: WorkflowDelayDuration | number;&#10;            backoff?: WorkflowBackoff;&#10;        };&#10;        timeout?: WorkflowTimeoutDuration | number;&#10;    };&#10;    export type WorkflowEvent&lt;T&gt; = {&#10;        payload: Readonly&lt;T&gt;;&#10;        timestamp: Date;&#10;        instanceId: string;&#10;    };&#10;    export type WorkflowStepEvent&lt;T&gt; = {&#10;        payload: Readonly&lt;T&gt;;&#10;        timestamp: Date;&#10;        type: string;&#10;    };&#10;    export abstract class WorkflowStep {&#10;        do&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;        do&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, config: WorkflowStepConfig, callback: () =&gt; Promise&lt;T&gt;): Promise&lt;T&gt;;&#10;        sleep: (name: string, duration: WorkflowSleepDuration) =&gt; Promise&lt;void&gt;;&#10;        sleepUntil: (name: string, timestamp: Date | number) =&gt; Promise&lt;void&gt;;&#10;        waitForEvent&lt;T extends Rpc.Serializable&lt;T&gt;&gt;(name: string, options: {&#10;            type: string;&#10;            timeout?: WorkflowTimeoutDuration | number;&#10;        }): Promise&lt;WorkflowStepEvent&lt;T&gt;&gt;;&#10;    }&#10;    export abstract class WorkflowEntrypoint&lt;Env = unknown, T extends Rpc.Serializable&lt;T&gt; | unknown = unknown&gt; implements Rpc.WorkflowEntrypointBranded {&#10;        [Rpc.__WORKFLOW_ENTRYPOINT_BRAND]: never;&#10;        protected ctx: ExecutionContext;&#10;        protected env: Env;&#10;        constructor(ctx: ExecutionContext, env: Env);&#10;        run(event: Readonly&lt;WorkflowEvent&lt;T&gt;&gt;, step: WorkflowStep): Promise&lt;unknown&gt;;&#10;    }&#10;    export function waitUntil(promise: Promise&lt;unknown&gt;): void;&#10;    export const env: Cloudflare.Env;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>