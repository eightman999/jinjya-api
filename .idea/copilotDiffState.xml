<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/api/draw.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/draw.ts" />
              <option name="originalContent" value="// src/api/draw.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDraw(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;const { searchParams } = new URL(request.url);&#10;&#9;const jinjyaId = searchParams.get(&quot;jinjya&quot;) || &quot;default&quot;;&#10;&#10;&#9;const listResponse = await env.JINJYA_STORE.list({ prefix: `buffer:${jinjyaId}:` });&#10;&#9;const keys = listResponse.keys.map((k: { name: string }) =&gt; k.name);&#10;&#10;&#9;if (keys.length === 0) {&#10;&#9;&#9;return new Response(&quot;まだ誰も奉納していません&quot;, { status: 404 });&#10;&#9;}&#10;&#10;&#9;// バッファ上限制御（例：100件超えたら古いもの削除）&#10;&#9;const MAX_BUFFER = 1000;&#10;&#9;if (keys.length &gt; MAX_BUFFER) {&#10;&#9;&#9;const sorted = keys.sort(); // timestamp順&#10;&#9;&#9;const excess = sorted.slice(0, keys.length - MAX_BUFFER);&#10;&#9;&#9;await Promise.all(excess.map(k =&gt; env.JINJYA_STORE.delete(k)));&#10;&#9;}&#10;&#10;&#9;// ランダムに1つ選ぶ&#10;&#9;const randomKey = keys[Math.floor(Math.random() * keys.length)];&#10;&#9;const omikujiStr = await env.JINJYA_STORE.get(randomKey);&#10;&#10;&#9;if (!omikujiStr) {&#10;&#9;&#9;return new Response(&quot;おみくじが壊れています…&quot;, { status: 500 });&#10;&#9;}&#10;&#10;&#9;return new Response(omikujiStr, {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;" />
              <option name="updatedContent" value="// src/api/draw.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDraw(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;const { searchParams } = new URL(request.url);&#10;&#9;const jinjyaId = searchParams.get(&quot;jinjya&quot;) || &quot;default&quot;;&#10;&#10;&#9;const listResponse = await env.JINJYA_STORE.list({ prefix: `buffer:${jinjyaId}:` });&#10;&#9;const keys = listResponse.keys.map((k: { name: string }) =&gt; k.name);&#10;&#10;&#9;if (keys.length === 0) {&#10;&#9;&#9;return new Response(&quot;まだ誰も奉納していません&quot;, { status: 404 });&#10;&#9;}&#10;&#10;&#9;// バッファ上限制御（例：100件超えたら古いもの削除）&#10;&#9;const MAX_BUFFER = 1000;&#10;&#9;if (keys.length &gt; MAX_BUFFER) {&#10;&#9;&#9;const sorted = keys.sort(); // timestamp順&#10;&#9;&#9;const excess = sorted.slice(0, keys.length - MAX_BUFFER);&#10;&#9;&#9;await Promise.all(excess.map((k: string) =&gt; env.JINJYA_STORE.delete(k)));&#10;&#9;}&#10;&#10;&#9;// ランダムに1つ選ぶ&#10;&#9;const randomKey = keys[Math.floor(Math.random() * keys.length)];&#10;&#9;const omikujiStr = await env.JINJYA_STORE.get(randomKey);&#10;&#10;&#9;if (!omikujiStr) {&#10;&#9;&#9;return new Response(&quot;おみくじが壊れています…&quot;, { status: 500 });&#10;&#9;}&#10;&#10;&#9;return new Response(omikujiStr, {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/publish.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/publish.ts" />
              <option name="originalContent" value="import { console, Env } from &quot;../../types/worker-configuration&quot;;&#10;&#10;const GAS_URL = &quot;https://script.google.com/macros/s/XXXXXXXXXXXXXXX/exec&quot;; // ← ここに本番URLを入れて&#10;&#10;const MAX_ITEMS = 20;&#10;const JINJYA_ID = &quot;furin&quot;;&#10;&#10;export async function handlePublish(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;// 1. キー一覧取得&#10;&#9;&#9;const list = await env.JINJYA_STORE.list({ prefix: `buffer:${JINJYA_ID}:` });&#10;&#9;&#9;const keys = list.keys.slice(0, MAX_ITEMS);&#10;&#10;&#9;&#9;if (keys.length === 0) {&#10;&#9;&#9;&#9;return new Response(&quot;No submissions to publish&quot;, { status: 200 });&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2. 中身を読み出し&#10;&#9;&#9;const values = await Promise.all(&#10;&#9;&#9;&#9;keys.map((entry) =&gt; env.JINJYA_STORE.get(entry.name))&#10;&#9;&#9;);&#10;&#10;&#9;&#9;// 3. GAS形式に整形&#10;&#9;&#9;const records = values&#10;&#9;&#9;&#9;.map((v) =&gt; (v ? JSON.parse(v) : null))&#10;&#9;&#9;&#9;.filter(Boolean); // nullを除く&#10;&#10;&#9;&#9;// 4. GASに送信&#10;&#9;&#9;const res = await fetch(GAS_URL, {&#10;&#9;&#9;&#9;method: &quot;POST&quot;,&#10;&#9;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;&#9;body: JSON.stringify(records),&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (!res.ok) {&#10;&#9;&#9;&#9;return new Response(&quot;GAS submission failed&quot;, { status: 500 });&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 5. 成功したら削除&#10;&#9;&#9;await Promise.all(&#10;&#9;&#9;&#9;keys.map((entry) =&gt; env.JINJYA_STORE.delete(entry.name))&#10;&#9;&#9;);&#10;&#10;&#9;&#9;return new Response(`Published ${records.length} submissions`, { status: 200 });&#10;&#10;&#9;} catch (err) {&#10;&#9;&#9;console.error(&quot;[Publish Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Internal error&quot;, { status: 500 });&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="import { console, Env } from &quot;../../types/worker-configuration&quot;;&#10;&#10;const GAS_URL = &quot;https://script.google.com/macros/s/XXXXXXXXXXXXXXX/exec&quot;; // ← ここに本番URLを入れて&#10;&#10;const MAX_ITEMS = 20;&#10;const JINJYA_ID = &quot;furin&quot;;&#10;&#10;export async function handlePublish(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;// 1. キー一覧取得&#10;&#9;&#9;const list = await env.JINJYA_STORE.list({ prefix: `buffer:${JINJYA_ID}:` });&#10;&#9;&#9;const keys = list.keys.slice(0, MAX_ITEMS);&#10;&#10;&#9;&#9;if (keys.length === 0) {&#10;&#9;&#9;&#9;return new Response(&quot;No submissions to publish&quot;, { status: 200 });&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2. 中身を読み出し&#10;&#9;&#9;const values = await Promise.all(&#10;&#9;&#9;&#9;keys.map((entry: { name: string }) =&gt; env.JINJYA_STORE.get(entry.name))&#10;&#9;&#9;);&#10;&#10;&#9;&#9;// 3. GAS形式に整形&#10;&#9;&#9;const records = values&#10;&#9;&#9;&#9;.map((v: string | null) =&gt; (v ? JSON.parse(v) : null))&#10;&#9;&#9;&#9;.filter(Boolean); // nullを除く&#10;&#10;&#9;&#9;// 4. GASに送信&#10;&#9;&#9;const res = await fetch(GAS_URL, {&#10;&#9;&#9;&#9;method: &quot;POST&quot;,&#10;&#9;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;&#9;body: JSON.stringify(records),&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (!res.ok) {&#10;&#9;&#9;&#9;return new Response(&quot;GAS submission failed&quot;, { status: 500 });&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 5. 成功したら削除&#10;&#9;&#9;await Promise.all(&#10;&#9;&#9;&#9;keys.map((entry: { name: string }) =&gt; env.JINJYA_STORE.delete(entry.name))&#10;&#9;&#9;);&#10;&#10;&#9;&#9;return new Response(`Published ${records.length} submissions`, { status: 200 });&#10;&#10;&#9;} catch (err) {&#10;&#9;&#9;console.error(&quot;[Publish Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Internal error&quot;, { status: 500 });&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/submit.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/submit.ts" />
              <option name="originalContent" value="// src/api/submit.ts&#10;import { z } from &quot;zod&quot;;&#10;import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from '../../types/worker-configuration';&#10;import { NG_WORDS } from &quot;../constants/ngWords&quot;;&#10;&#10;&#10;const MAX_LENGTH = 200;&#10;/**&#10; * NGワードが含まれているかチェックする関数&#10; * @param text チェックするテキスト&#10; * @returns NGワードが含まれていればtrue、そうでなければfalse&#10; */&#10;function containsNGWords(text: string): boolean {&#10;&#9;return NG_WORDS.some((word) =&gt; text.includes(word));&#10;}&#10;&#10;export async function handleSubmit(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;const body = await request.json();&#10;&#10;&#9;&#9;// ✅ スキーマ検証&#10;&#9;&#9;const omikuji = OmikujiSchema.parse(body);&#10;&#10;&#9;&#9;// ✅ NGワードチェック &amp; 文字数制限&#10;&#9;&#9;for (const key of Object.keys(omikuji)) {&#10;&#9;&#9;&#9;const value = omikuji[key as keyof typeof omikuji];&#10;&#9;&#9;&#9;if (typeof value === &quot;string&quot;) {&#10;&#9;&#9;&#9;&#9;if (value.length &gt; MAX_LENGTH) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Too long input&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;if (containsNGWords(value)) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Inappropriate content&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ✅ バッファキーを作成&#10;&#9;&#9;const timestamp = Date.now();&#10;&#9;&#9;const jinjyaId = omikuji.jinjya || &quot;default&quot;;&#10;&#9;&#9;const kvKey = `buffer:${jinjyaId}:${timestamp}`;&#10;&#10;&#9;&#9;// ✅ 保存&#10;&#9;&#9;await env.JINJYA_STORE.put(kvKey, JSON.stringify(omikuji));&#10;&#10;&#9;&#9;return new Response(&quot;奉納を受け付けました&quot;, { status: 200 });&#10;&#9;} catch (err: any) {&#10;&#9;&#9;console.error(&quot;[Submit Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Invalid submission&quot;, { status: 400 });&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="// src/api/submit.ts&#10;import { z } from &quot;zod&quot;;&#10;import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from '../../types/worker-configuration';&#10;import { NG_WORDS } from &quot;../constants/ngWords&quot;;&#10;&#10;&#10;const MAX_LENGTH = 200;&#10;/**&#10; * NGワードが含まれているかチェックする関数&#10; * @param text チェックするテキスト&#10; * @returns NGワードが含まれていればtrue、そうでなければfalse&#10; */&#10;function containsNGWords(text: string): boolean {&#10;&#9;return NG_WORDS.some((word) =&gt; text.includes(word));&#10;}&#10;&#10;export async function handleSubmit(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;const body = await request.json();&#10;&#10;&#9;&#9;// ✅ スキーマ検証&#10;&#9;&#9;const omikuji = OmikujiSchema.parse(body);&#10;&#10;&#9;&#9;// ✅ NGワードチェック &amp; 文字数制限&#10;&#9;&#9;for (const key of Object.keys(omikuji)) {&#10;&#9;&#9;&#9;const value = omikuji[key as keyof typeof omikuji];&#10;&#9;&#9;&#9;if (typeof value === &quot;string&quot;) {&#10;&#9;&#9;&#9;&#9;if (value.length &gt; MAX_LENGTH) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Too long input&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;if (containsNGWords(value)) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Inappropriate content&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ✅ バッファキーを作成&#10;&#9;&#9;const jinjyaId = &quot;furin&quot;; // Ver0では固定&#10;&#9;&#9;const kvKey = `buffer:${jinjyaId}:${Date.now()}`;&#10;&#10;&#9;&#9;// ✅ 保存&#10;&#9;&#9;await env.JINJYA_STORE.put(kvKey, JSON.stringify(omikuji));&#10;&#10;&#9;&#9;return new Response(&quot;奉納を受け付けました&quot;, { status: 200 });&#10;&#9;} catch (err: any) {&#10;&#9;&#9;console.error(&quot;[Submit Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Invalid submission&quot;, { status: 400 });&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/types/worker-configuration.d.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/types/worker-configuration.d.ts" />
              <option name="originalContent" value="// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;// ...既存の worker-configuration.d.ts の内容を移動...&#10;interface Env extends Cloudflare.Env {}&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;interface Env extends Cloudflare.Env {}&#10;// ...省略...&#10;export {}&#10;// ...省略...&#10;" />
              <option name="updatedContent" value="/* eslint-disable */&#10;// Generated by Wrangler by running `wrangler types` (hash: 869ac3b4ce0f52ba3b2e0bc70c49089e)&#10;// Runtime types generated with workerd@1.20250730.0 2025-08-02&#10;declare namespace Cloudflare {&#10;&#9;interface Env {&#10;&#9;&#9;JINJYA_STORE: KVNamespace;&#10;&#9;}&#10;}&#10;&#10;export interface Env extends Cloudflare.Env {}&#10;export {}&#10;&#10;export const console = globalThis.console;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>