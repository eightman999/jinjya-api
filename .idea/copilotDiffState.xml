<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/api/jinjya_register.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_register.ts" />
              <option name="originalContent" value="// src/api/jinjya_register.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleJinjyaRegister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;const body = await request.json();&#10;&#9;const { id, name, spreadsheet_url, owner } = body;&#10;&#10;&#9;if (!id || !name || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing fields&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;try {&#10;&#9;&#9;await env.DB.prepare(`&#10;      INSERT INTO jinjya (id, name, spreadsheet_url, owner)&#10;      VALUES (?, ?, ?, ?)&#10;    `).bind(id, name, spreadsheet_url, owner || null).run();&#10;&#10;&#9;&#9;return new Response(&quot;神社を登録しました⛩️&quot;, { status: 200 });&#10;&#9;} catch (e) {&#10;&#9;&#9;return new Response(&quot;登録失敗：&quot; + e.message, { status: 500 });&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="// src/api/jinjya_register.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleJinjyaRegister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;const body = await request.json();&#10;&#9;const { id, name, spreadsheet_url, owner } = body;&#10;&#10;&#9;if (!id || !name || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing fields&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;try {&#10;&#9;&#9;await env.DB.prepare(`&#10;      INSERT INTO jinjya (id, name, spreadsheet_url, owner)&#10;      VALUES (?, ?, ?, ?)&#10;    `).bind(id, name, spreadsheet_url, owner || null).run();&#10;&#10;&#9;&#9;return new Response(&quot;神社を登録しました⛩️&quot;, { status: 200 });&#10;&#9;} catch (e) {&#10;&#9;&#9;if (e instanceof Error) {&#10;&#9;&#9;&#9;return new Response(&quot;登録失敗：&quot; + e.message, { status: 500 });&#10;&#9;&#9;}&#10;&#9;&#9;return new Response(&quot;登録失敗：不明なエラー&quot;, { status: 500 });&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/submit.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/submit.ts" />
              <option name="originalContent" value="// src/api/submit.ts&#10;import { z } from &quot;zod&quot;;&#10;import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from '../../types/worker-configuration';&#10;import { NG_WORDS } from &quot;../constants/ngWords&quot;;&#10;&#10;&#10;const MAX_LENGTH = 200;&#10;/**&#10; * NGワードが含まれているかチェックする関数&#10; * @param text チェックするテキスト&#10; * @returns NGワードが含まれていればtrue、そうでなければfalse&#10; */&#10;function containsNGWords(text: string): boolean {&#10;&#9;return NG_WORDS.some((word) =&gt; text.includes(word));&#10;}&#10;&#10;export async function handleSubmit(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;const body = await request.json();&#10;&#10;&#9;&#9;// ✅ スキーマ検証&#10;&#9;&#9;const omikuji = OmikujiSchema.parse(body);&#10;&#10;&#9;&#9;// ✅ NGワードチェック &amp; 文字数制限&#10;&#9;&#9;for (const key of Object.keys(omikuji)) {&#10;&#9;&#9;&#9;const value = omikuji[key as keyof typeof omikuji];&#10;&#9;&#9;&#9;if (typeof value === &quot;string&quot;) {&#10;&#9;&#9;&#9;&#9;if (value.length &gt; MAX_LENGTH) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Too long input&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;if (containsNGWords(value)) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Inappropriate content&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ✅ バッファキーを作成&#10;&#9;&#9;const jinjyaId = &quot;furin&quot;; // Ver0では固定&#10;&#9;&#9;const kvKey = `buffer:${jinjyaId}:${Date.now()}`;&#10;&#10;&#9;&#9;// ✅ 保存&#10;&#9;&#9;await env.JINJYA_STORE.put(kvKey, JSON.stringify(omikuji));&#10;&#10;&#9;&#9;return new Response(&quot;奉納を受け付けました&quot;, { status: 200 });&#10;&#9;} catch (err: any) {&#10;&#9;&#9;console.error(&quot;[Submit Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Invalid submission&quot;, { status: 400 });&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="// src/api/submit.ts&#10;import { z } from &quot;zod&quot;;&#10;import { OmikujiSchema } from &quot;./schema&quot;;&#10;import type { Env } from '../../types/worker-configuration';&#10;import { NG_WORDS } from &quot;../constants/ngWords&quot;;&#10;&#10;&#10;const MAX_LENGTH = 200;&#10;/**&#10; * NGワードが含まれているかチェックする関数&#10; * @param text チェックするテキスト&#10; * @returns NGワードが含まれていればtrue、そうでなければfalse&#10; */&#10;function containsNGWords(text: string): boolean {&#10;&#9;return NG_WORDS.some((word) =&gt; text.includes(word));&#10;}&#10;&#10;export async function handleSubmit(&#10;&#9;request: Request,&#10;&#9;env: Env&#10;): Promise&lt;Response&gt; {&#10;&#9;try {&#10;&#9;&#9;const body = await request.json();&#10;&#10;&#9;&#9;// ✅ スキーマ検証&#10;&#9;&#9;const omikuji = OmikujiSchema.parse(body);&#10;&#10;&#9;&#9;// ✅ NGワードチェック &amp; 文字数制限&#10;&#9;&#9;for (const key of Object.keys(omikuji)) {&#10;&#9;&#9;&#9;const value = omikuji[key as keyof typeof omikuji];&#10;&#9;&#9;&#9;if (typeof value === &quot;string&quot;) {&#10;&#9;&#9;&#9;&#9;if (value.length &gt; MAX_LENGTH) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Too long input&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;if (containsNGWords(value)) {&#10;&#9;&#9;&#9;&#9;&#9;return new Response(&quot;Inappropriate content&quot;, { status: 400 });&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// ✅ バッファキーを作成&#10;&#9;&#9;const jinjyaId = body.jinjya ?? &quot;default&quot;;&#10;&#9;&#9;const timestamp = Date.now();&#10;&#9;&#9;const key = `buffer:${jinjyaId}:${timestamp}`;&#10;&#10;&#9;&#9;// ✅ 保存&#10;&#9;&#9;await env.JINJYA_STORE.put(key, JSON.stringify(omikuji));&#10;&#10;&#9;&#9;return new Response(&quot;奉納を受け付けました&quot;, { status: 200 });&#10;&#9;} catch (err: any) {&#10;&#9;&#9;console.error(&quot;[Submit Error]&quot;, err);&#10;&#9;&#9;return new Response(&quot;Invalid submission&quot;, { status: 400 });&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>