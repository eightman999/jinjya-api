<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/api/jinjya_deregister.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_deregister.ts" />
              <option name="originalContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDeregister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;let data: any;&#10;&#9;try {&#10;&#9;&#9;data = await request.json();&#10;&#9;} catch {&#10;&#9;&#9;return new Response(&quot;Invalid JSON&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const { id, owner, spreadsheet_url } = data;&#10;&#9;if (!id || !owner || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing required fields&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;// 一致するレコードの確認&#10;&#9;const check = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id FROM jinjya WHERE id = ? AND owner = ? AND spreadsheet_url = ?`&#10;&#9;).bind(id, owner, spreadsheet_url).first();&#10;&#10;&#9;if (!check) {&#10;&#9;&#9;return new Response(&quot;一致する神社が見つかりません&quot;, { status: 404 });&#10;&#9;}&#10;&#10;&#9;// 削除実行&#10;&#9;await env.JINJYA_DB.prepare(&#10;&#9;&#9;`DELETE FROM jinjya WHERE id = ?`&#10;&#9;).bind(id).run();&#10;&#10;&#9;return new Response(&quot;神社を削除しました&quot;, { status: 200 });&#10;}&#10;" />
              <option name="updatedContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleDeregister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;let data: any;&#10;&#9;try {&#10;&#9;&#9;data = await request.json();&#10;&#9;} catch {&#10;&#9;&#9;return new Response(&quot;Invalid JSON&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const { id, owner, spreadsheet_url } = data;&#10;&#10;&#9;if (!id || !owner || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing required fields (id, owner, spreadsheet_url)&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;const record = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT owner, spreadsheet_url FROM jinjya WHERE id = ? LIMIT 1`&#10;&#9;).bind(id).first&lt;{ owner: string, spreadsheet_url: string }&gt;();&#10;&#10;&#9;if (!record) {&#10;&#9;&#9;return new Response(&quot;神社が見つかりません&quot;, { status: 404 });&#10;&#9;}&#10;&#10;&#9;if (record.owner !== owner || record.spreadsheet_url !== spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;認証エラー：オーナーまたはURLが一致しません&quot;, { status: 403 });&#10;&#9;}&#10;&#10;&#9;await env.JINJYA_DB.prepare(&#10;&#9;&#9;`DELETE FROM jinjya WHERE id = ?`&#10;&#9;).bind(id).run();&#10;&#10;&#9;return new Response(`神社「${id}」を削除しました`, { status: 200 });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/jinjya_list.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_list.ts" />
              <option name="originalContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleJinjyaList(env: Env): Promise&lt;Response&gt; {&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, spreadsheet_url, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;&#10;export async function handleList(env: Env): Promise&lt;Response&gt; {&#10;  const result = await env.JINJYA_DB.prepare(&#10;    `SELECT id, name, spreadsheet_url, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;  ).all();&#10;&#10;  return new Response(JSON.stringify(result.results), {&#10;    headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;    status: 200,&#10;  });&#10;}&#10;" />
              <option name="updatedContent" value="import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleJinjyaList(env: Env): Promise&lt;Response&gt; {&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}&#10;&#10;export async function handleList(env: Env): Promise&lt;Response&gt; {&#10;&#9;const result = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id, name, owner, created_at FROM jinjya ORDER BY created_at DESC`&#10;&#9;).all();&#10;&#10;&#9;return new Response(JSON.stringify(result.results), {&#10;&#9;&#9;headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;&#9;&#9;status: 200,&#10;&#9;});&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/jinjya_register.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/jinjya_register.ts" />
              <option name="originalContent" value="// src/api/jinjya_register.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleRegister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;const data = await request.json();&#10;&#9;const { id, name, spreadsheet_url, owner } = data;&#10;&#10;&#9;if (!id || !name || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing required fields&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;// 重複チェック&#10;&#9;const check = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id FROM jinjya WHERE id = ?`&#10;&#9;).bind(id).first();&#10;&#10;&#9;if (check) {&#10;&#9;&#9;return new Response(&quot;神社IDが既に存在します&quot;, { status: 409 });&#10;&#9;}&#10;&#10;&#9;// 挿入&#10;&#9;await env.JINJYA_DB.prepare(&#10;&#9;&#9;`INSERT INTO jinjya (id, name, spreadsheet_url, owner) VALUES (?, ?, ?, ?)`&#10;&#9;).bind(id, name, spreadsheet_url, owner || null).run();&#10;&#10;&#9;return new Response(&quot;神社を登録しました&quot;, { status: 201 });&#10;}&#10;" />
              <option name="updatedContent" value="// src/api/jinjya_register.ts&#10;import { Env } from '../../types/worker-configuration';&#10;&#10;export async function handleRegister(request: Request, env: Env): Promise&lt;Response&gt; {&#10;&#9;console.log(&quot; handleRegister invoked&quot;);&#10;&#9;console.log(&quot; env.JINJYA_DB =&quot;, env.JINJYA_DB);&#10;&#10;&#9;if (request.method !== &quot;POST&quot;) {&#10;&#9;&#9;return new Response(&quot;Method Not Allowed&quot;, { status: 405 });&#10;&#9;}&#10;&#10;&#9;const data = await request.json();&#10;&#9;const { id, name, spreadsheet_url, owner } = data;&#10;&#10;&#9;if (!id || !name || !spreadsheet_url) {&#10;&#9;&#9;return new Response(&quot;Missing required fields&quot;, { status: 400 });&#10;&#9;}&#10;&#10;&#9;// 重複チェック&#10;&#9;const check = await env.JINJYA_DB.prepare(&#10;&#9;&#9;`SELECT id FROM jinjya WHERE id = ?`&#10;&#9;).bind(id).first();&#10;&#10;&#9;if (check) {&#10;&#9;&#9;return new Response(&quot;神社IDが既に存在します&quot;, { status: 409 });&#10;&#9;}&#10;&#10;&#9;// 挿入&#10;&#9;await env.JINJYA_DB.prepare(&#10;&#9;&#9;`INSERT INTO jinjya (id, name, spreadsheet_url, owner) VALUES (?, ?, ?, ?)`&#10;&#9;).bind(id, name, spreadsheet_url, owner || null).run();&#10;&#10;&#9;return new Response(&quot;神社を登録しました&quot;, { status: 201 });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="import { handleSubmit } from &quot;./api/submit&quot;;&#10;import { handleDraw } from &quot;./api/draw&quot;;&#10;import { Env } from '../types/worker-configuration';&#10;import { ExecutionContext, ScheduledEvent } from '@cloudflare/workers-types';&#10;import { handlePublish } from &quot;./api/publish&quot;;&#10;import { handleRead } from &quot;./api/read&quot;;&#10;import { handleList } from &quot;./api/jinjya_list&quot;;&#10;import { handleRegister } from &quot;./api/jinjya_register&quot;;&#10;import { handleDeregister } from './api/jinjya_deregister';&#10;&#10;async function handleCron(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {&#10;&#9;console.log(&quot;⛩️ Cron Trigger発動: Publishing...&quot;);&#10;&#9;await handlePublish(env);&#10;}&#10;&#10;export default {&#10;&#9;async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {&#10;&#9;&#9;const url = new URL(request.url);&#10;&#9;&#9;const { pathname } = url;&#10;&#10;&#9;&#9;console.log(&quot; Request received:&quot;, {&#10;&#9;&#9;&#9;pathname,&#10;&#9;&#9;&#9;method: request.method,&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (request.method === &quot;POST&quot; &amp;&amp; url.pathname === &quot;/api/publish&quot;) {&#10;&#9;&#9;&#9;return await handlePublish(env);&#10;&#9;&#9;}&#10;&#9;&#9;if (pathname === &quot;/api/submit&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleSubmit(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (pathname === &quot;/api/draw&quot; &amp;&amp; request.method === &quot;GET&quot;) {&#10;&#9;&#9;&#9;return await handleDraw(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (request.method === &quot;GET&quot; &amp;&amp; url.pathname === &quot;/api/read&quot;) {&#10;&#9;&#9;&#9;return await handleRead(env);&#10;&#9;&#9;}&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/list&quot; &amp;&amp; request.method === &quot;GET&quot;) {&#10;&#9;&#9;&#9;return await handleList(env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/register&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleRegister(request, env);&#10;&#9;&#9;}&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/deregister&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleDeregister(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return new Response(`Not Found: ${pathname}`, { status: 404 });&#10;&#9;},&#10;&#10;&#9;async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {&#10;&#9;&#9;await handleCron(event, env, ctx);&#10;&#9;},&#10;};&#10;" />
              <option name="updatedContent" value="import { handleSubmit } from &quot;./api/submit&quot;;&#10;import { handleDraw } from &quot;./api/draw&quot;;&#10;import { Env } from '../types/worker-configuration';&#10;import { ExecutionContext, ScheduledEvent } from '@cloudflare/workers-types';&#10;import { handlePublish } from &quot;./api/publish&quot;;&#10;import { handleRead } from &quot;./api/read&quot;;&#10;import { handleList } from &quot;./api/jinjya_list&quot;;&#10;import { handleRegister } from &quot;./api/jinjya_register&quot;;&#10;import { handleDeregister } from &quot;./api/jinjya_deregister&quot;;&#10;&#10;async function handleCron(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {&#10;&#9;console.log(&quot;⛩️ Cron Trigger発動: Publishing...&quot;);&#10;&#9;await handlePublish(env);&#10;}&#10;&#10;export default {&#10;&#9;async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise&lt;Response&gt; {&#10;&#9;&#9;const url = new URL(request.url);&#10;&#9;&#9;const { pathname } = url;&#10;&#10;&#9;&#9;console.log(&quot; Request received:&quot;, {&#10;&#9;&#9;&#9;pathname,&#10;&#9;&#9;&#9;method: request.method,&#10;&#9;&#9;});&#10;&#10;&#9;&#9;if (request.method === &quot;POST&quot; &amp;&amp; url.pathname === &quot;/api/publish&quot;) {&#10;&#9;&#9;&#9;return await handlePublish(env);&#10;&#9;&#9;}&#10;&#9;&#9;if (pathname === &quot;/api/submit&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleSubmit(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (pathname === &quot;/api/draw&quot; &amp;&amp; request.method === &quot;GET&quot;) {&#10;&#9;&#9;&#9;return await handleDraw(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (request.method === &quot;GET&quot; &amp;&amp; url.pathname === &quot;/api/read&quot;) {&#10;&#9;&#9;&#9;return await handleRead(env);&#10;&#9;&#9;}&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/list&quot; &amp;&amp; request.method === &quot;GET&quot;) {&#10;&#9;&#9;&#9;return await handleList(env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/register&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleRegister(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if (pathname === &quot;/api/jinjya/deregister&quot; &amp;&amp; request.method === &quot;POST&quot;) {&#10;&#9;&#9;&#9;return await handleDeregister(request, env);&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return new Response(`Not Found: ${pathname}`, { status: 404 });&#10;&#9;},&#10;&#10;&#9;async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext) {&#10;&#9;&#9;await handleCron(event, env, ctx);&#10;&#9;},&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>